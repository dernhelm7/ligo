contract: Type Ident EQ VBAR Attr With
##
## Ends in an error in state: 47.
##
## variant -> nseq(Attr) . Constr [ VBAR Type SEMI RPAR RBRACE Module Let In End EQ EOF Directive COMMA Attr ]
## variant -> nseq(Attr) . Constr Of fun_type [ VBAR Type SEMI RPAR RBRACE Module Let In End EQ EOF Directive COMMA Attr ]
##
## The known suffix of the stack is as follows:
## nseq(Attr)
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 45, spurious reduction of production seq(Attr) ->
## In state 46, spurious reduction of production nseq(Attr) -> Attr seq(Attr)
##

Ill-formed variant.
At this point, if the attributes are complete, a data constructor is
expected.

contract: Type Ident EQ Attr Constr Of With
##
## Ends in an error in state: 49.
##
## variant -> nseq(Attr) Constr Of . fun_type [ VBAR Type SEMI RPAR RBRACE Module Let In End EQ EOF Directive COMMA Attr ]
##
## The known suffix of the stack is as follows:
## nseq(Attr) Constr Of
##

Ill-formed variant.
At this point, a type other than a sum type or a record is expected.

interactive_expr: Begin Fun WILD ARROW Bytes SEMI
##
## Ends in an error in state: 592.
##
## sequence -> Begin option(series) . End [ With Verbatim VBAR Type True Then TIMES String SLASH SEMI RPAR RBRACKET RBRACE PLUS Or Nat NE Mutez Module Mod MINUS Let Lang LT LPAR LE LBRACKET LBRACE Int In Ident GT GE False End Else EQ EOF Directive Constr C_None CONS COMMA COLON CARET Bytes Begin BOOL_OR BOOL_AND Attr ]
##
## The known suffix of the stack is as follows:
## Begin option(series)
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 218, spurious reduction of production call_expr_level -> core_expr
## In state 224, spurious reduction of production unary_expr_level -> call_expr_level
## In state 205, spurious reduction of production mult_expr_level -> unary_expr_level
## In state 215, spurious reduction of production add_expr_level -> mult_expr_level
## In state 255, spurious reduction of production cons_expr_level -> add_expr_level
## In state 245, spurious reduction of production cat_expr_level -> cons_expr_level
## In state 277, spurious reduction of production comp_expr_level -> cat_expr_level
## In state 284, spurious reduction of production conj_expr_level -> comp_expr_level
## In state 291, spurious reduction of production disj_expr_level -> conj_expr_level
## In state 577, spurious reduction of production seq_expr -> disj_expr_level
## In state 526, spurious reduction of production last_expr -> seq_expr
## In state 581, spurious reduction of production fun_expr(last_expr) -> Fun nseq(irrefutable) ARROW last_expr
## In state 576, spurious reduction of production last_expr -> fun_expr(last_expr)
## In state 575, spurious reduction of production series -> last_expr
## In state 591, spurious reduction of production option(series) -> series
##

Ill-formed sequence of expressions.
At this point, if the expression is complete, one of the following is
expected:
  * a semicolon ';' followed by another expression;
  * the keyword 'end' if the sequence is complete.

interactive_expr: Begin If Verbatim Then Verbatim Else With
##
## Ends in an error in state: 562.
##
## if_then_else(seq_expr) -> If expr Then closed_if Else . seq_expr [ SEMI End ]
##
## The known suffix of the stack is as follows:
## If expr Then closed_if Else
##

Ill-formed conditional expression.
At this point, the expression of the 'else' branch is expected.

interactive_expr: Begin Match Verbatim With WILD ARROW Fun WILD ARROW With
##
## Ends in an error in state: 527.
##
## let_expr(base_cond) -> seq(Attr) . Let let_binding In base_cond [ VBAR ]
## let_expr(base_cond) -> seq(Attr) . Let Rec let_binding In base_cond [ VBAR ]
## let_in_sequence -> seq(Attr) . Let let_binding In series [ End ]
## let_in_sequence -> seq(Attr) . Let Rec let_binding In series [ End ]
##
## The known suffix of the stack is as follows:
## seq(Attr)
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 524, spurious reduction of production seq(Attr) ->
##
interactive_expr: If Verbatim Then Match Verbatim With WILD ARROW With
##
## Ends in an error in state: 458.
##
## let_expr(base_cond) -> seq(Attr) . Let let_binding In base_cond [ With VBAR Type Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF Directive COLON Attr ]
## let_expr(base_cond) -> seq(Attr) . Let Rec let_binding In base_cond [ With VBAR Type Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF Directive COLON Attr ]
## let_expr(base_if_then_else) -> seq(Attr) . Let let_binding In base_if_then_else [ Else ]
## let_expr(base_if_then_else) -> seq(Attr) . Let Rec let_binding In base_if_then_else [ Else ]
##
## The known suffix of the stack is as follows:
## seq(Attr)
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 385, spurious reduction of production seq(Attr) ->
##
interactive_expr: Begin With
##
## Ends in an error in state: 568.
##
## let_in_sequence -> seq(Attr) . Let let_binding In series [ End ]
## let_in_sequence -> seq(Attr) . Let Rec let_binding In series [ End ]
##
## The known suffix of the stack is as follows:
## seq(Attr)
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 189, spurious reduction of production seq(Attr) ->
##
interactive_expr: Begin If Verbatim Then With
##
## Ends in an error in state: 547.
##
## let_expr(closed_if) -> seq(Attr) . Let let_binding In closed_if [ Else ]
## let_expr(closed_if) -> seq(Attr) . Let Rec let_binding In closed_if [ Else ]
##
## The known suffix of the stack is as follows:
## seq(Attr)
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 537, spurious reduction of production seq(Attr) ->
##
interactive_expr: If Verbatim Then With
##
## Ends in an error in state: 612.
##
## let_expr(closed_if) -> seq(Attr) . Let let_binding In closed_if [ Else ]
## let_expr(closed_if) -> seq(Attr) . Let Rec let_binding In closed_if [ Else ]
## let_expr(expr) -> seq(Attr) . Let let_binding In expr [ With Type Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF Directive COLON Attr ]
## let_expr(expr) -> seq(Attr) . Let Rec let_binding In expr [ With Type Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF Directive COLON Attr ]
##
## The known suffix of the stack is as follows:
## seq(Attr)
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 597, spurious reduction of production seq(Attr) ->
##
interactive_expr: Match Verbatim With WILD ARROW If Verbatim Then With
##
## Ends in an error in state: 398.
##
## let_expr(base_cond) -> seq(Attr) . Let let_binding In base_cond [ With VBAR Type Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF Directive COLON Attr ]
## let_expr(base_cond) -> seq(Attr) . Let Rec let_binding In base_cond [ With VBAR Type Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF Directive COLON Attr ]
## let_expr(closed_if) -> seq(Attr) . Let let_binding In closed_if [ Else ]
## let_expr(closed_if) -> seq(Attr) . Let Rec let_binding In closed_if [ Else ]
##
## The known suffix of the stack is as follows:
## seq(Attr)
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 501, spurious reduction of production seq(Attr) ->
##
interactive_expr: Match Verbatim With WILD ARROW Let WILD EQ Bytes In With
##
## Ends in an error in state: 507.
##
## let_expr(base_cond) -> seq(Attr) . Let let_binding In base_cond [ With VBAR Type Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF Directive COLON Attr ]
## let_expr(base_cond) -> seq(Attr) . Let Rec let_binding In base_cond [ With VBAR Type Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF Directive COLON Attr ]
##
## The known suffix of the stack is as follows:
## seq(Attr)
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 518, spurious reduction of production seq(Attr) ->
##
interactive_expr: With
##
## Ends in an error in state: 210.
##
## let_expr(expr) -> seq(Attr) . Let let_binding In expr [ With Type Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF Directive COLON Attr ]
## let_expr(expr) -> seq(Attr) . Let Rec let_binding In expr [ With Type Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF Directive COLON Attr ]
##
## The known suffix of the stack is as follows:
## seq(Attr)
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 718, spurious reduction of production seq(Attr) ->
##
contract: With
##
## Ends in an error in state: 94.
##
## let_declaration -> seq(Attr) . Let let_binding [ Type Module Let End EOF Directive Attr ]
## let_declaration -> seq(Attr) . Let Rec let_binding [ Type Module Let End EOF Directive Attr ]
##
## The known suffix of the stack is as follows:
## seq(Attr)
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 0, spurious reduction of production seq(Attr) ->
##

Ill-formed value declaration.
At this point, if the attributes (if any) are complete, the keyword
'let' is expected.

interactive_expr: Match Verbatim With WILD ARROW If Verbatim Then If Verbatim Then Verbatim WILD
##
## Ends in an error in state: 445.
##
## if_then_else(base_cond) -> If expr Then closed_if . Else base_cond [ With VBAR Type Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF Directive COLON Attr ]
## if_then_else(closed_if) -> If expr Then closed_if . Else closed_if [ Else ]
##
## The known suffix of the stack is as follows:
## If expr Then closed_if
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 218, spurious reduction of production call_expr_level -> core_expr
## In state 224, spurious reduction of production unary_expr_level -> call_expr_level
## In state 205, spurious reduction of production mult_expr_level -> unary_expr_level
## In state 215, spurious reduction of production add_expr_level -> mult_expr_level
## In state 255, spurious reduction of production cons_expr_level -> add_expr_level
## In state 245, spurious reduction of production cat_expr_level -> cons_expr_level
## In state 277, spurious reduction of production comp_expr_level -> cat_expr_level
## In state 284, spurious reduction of production conj_expr_level -> comp_expr_level
## In state 291, spurious reduction of production disj_expr_level -> conj_expr_level
## In state 421, spurious reduction of production base_expr(closed_if) -> disj_expr_level
## In state 425, spurious reduction of production base_if_then_else__open(closed_if) -> base_expr(closed_if)
## In state 424, spurious reduction of production closed_if -> base_if_then_else__open(closed_if)
##
interactive_expr: Begin If Verbatim Then If Verbatim Then Verbatim COMMA Bytes With
##
## Ends in an error in state: 559.
##
## if_then_else(closed_if) -> If expr Then closed_if . Else closed_if [ Else ]
##
## The known suffix of the stack is as follows:
## If expr Then closed_if
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 218, spurious reduction of production call_expr_level -> core_expr
## In state 224, spurious reduction of production unary_expr_level -> call_expr_level
## In state 205, spurious reduction of production mult_expr_level -> unary_expr_level
## In state 215, spurious reduction of production add_expr_level -> mult_expr_level
## In state 255, spurious reduction of production cons_expr_level -> add_expr_level
## In state 245, spurious reduction of production cat_expr_level -> cons_expr_level
## In state 277, spurious reduction of production comp_expr_level -> cat_expr_level
## In state 284, spurious reduction of production conj_expr_level -> comp_expr_level
## In state 291, spurious reduction of production disj_expr_level -> conj_expr_level
## In state 288, spurious reduction of production nsepseq(disj_expr_level,COMMA) -> disj_expr_level
## In state 287, spurious reduction of production tuple(disj_expr_level) -> disj_expr_level COMMA nsepseq(disj_expr_level,COMMA)
## In state 209, spurious reduction of production tuple_expr -> tuple(disj_expr_level)
## In state 546, spurious reduction of production base_expr(closed_if) -> tuple_expr
## In state 425, spurious reduction of production base_if_then_else__open(closed_if) -> base_expr(closed_if)
## In state 424, spurious reduction of production closed_if -> base_if_then_else__open(closed_if)
##
interactive_expr: Begin If Verbatim Then Verbatim With
##
## Ends in an error in state: 561.
##
## if_then_else(seq_expr) -> If expr Then closed_if . Else seq_expr [ SEMI End ]
##
## The known suffix of the stack is as follows:
## If expr Then closed_if
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 218, spurious reduction of production call_expr_level -> core_expr
## In state 224, spurious reduction of production unary_expr_level -> call_expr_level
## In state 205, spurious reduction of production mult_expr_level -> unary_expr_level
## In state 215, spurious reduction of production add_expr_level -> mult_expr_level
## In state 255, spurious reduction of production cons_expr_level -> add_expr_level
## In state 245, spurious reduction of production cat_expr_level -> cons_expr_level
## In state 277, spurious reduction of production comp_expr_level -> cat_expr_level
## In state 284, spurious reduction of production conj_expr_level -> comp_expr_level
## In state 291, spurious reduction of production disj_expr_level -> conj_expr_level
## In state 556, spurious reduction of production base_expr(closed_if) -> disj_expr_level
## In state 425, spurious reduction of production base_if_then_else__open(closed_if) -> base_expr(closed_if)
## In state 424, spurious reduction of production closed_if -> base_if_then_else__open(closed_if)
##
interactive_expr: If Verbatim Then Match Verbatim With WILD ARROW If Verbatim Then Verbatim WILD
##
## Ends in an error in state: 450.
##
## if_then_else(base_cond) -> If expr Then closed_if . Else base_cond [ With VBAR Type Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF Directive COLON Attr ]
## if_then_else(base_if_then_else) -> If expr Then closed_if . Else base_if_then_else [ Else ]
##
## The known suffix of the stack is as follows:
## If expr Then closed_if
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 218, spurious reduction of production call_expr_level -> core_expr
## In state 224, spurious reduction of production unary_expr_level -> call_expr_level
## In state 205, spurious reduction of production mult_expr_level -> unary_expr_level
## In state 215, spurious reduction of production add_expr_level -> mult_expr_level
## In state 255, spurious reduction of production cons_expr_level -> add_expr_level
## In state 245, spurious reduction of production cat_expr_level -> cons_expr_level
## In state 277, spurious reduction of production comp_expr_level -> cat_expr_level
## In state 284, spurious reduction of production conj_expr_level -> comp_expr_level
## In state 291, spurious reduction of production disj_expr_level -> conj_expr_level
## In state 421, spurious reduction of production base_expr(closed_if) -> disj_expr_level
## In state 425, spurious reduction of production base_if_then_else__open(closed_if) -> base_expr(closed_if)
## In state 424, spurious reduction of production closed_if -> base_if_then_else__open(closed_if)
##
interactive_expr: Begin Match Verbatim With WILD ARROW If Verbatim Then Verbatim WILD
##
## Ends in an error in state: 494.
##
## if_then_else(base_cond) -> If expr Then closed_if . Else base_cond [ VBAR ]
## if_then_else(seq_expr) -> If expr Then closed_if . Else seq_expr [ SEMI End ]
##
## The known suffix of the stack is as follows:
## If expr Then closed_if
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 218, spurious reduction of production call_expr_level -> core_expr
## In state 224, spurious reduction of production unary_expr_level -> call_expr_level
## In state 205, spurious reduction of production mult_expr_level -> unary_expr_level
## In state 215, spurious reduction of production add_expr_level -> mult_expr_level
## In state 255, spurious reduction of production cons_expr_level -> add_expr_level
## In state 245, spurious reduction of production cat_expr_level -> cons_expr_level
## In state 277, spurious reduction of production comp_expr_level -> cat_expr_level
## In state 284, spurious reduction of production conj_expr_level -> comp_expr_level
## In state 291, spurious reduction of production disj_expr_level -> conj_expr_level
## In state 421, spurious reduction of production base_expr(closed_if) -> disj_expr_level
## In state 425, spurious reduction of production base_if_then_else__open(closed_if) -> base_expr(closed_if)
## In state 424, spurious reduction of production closed_if -> base_if_then_else__open(closed_if)
##
interactive_expr: Match Verbatim With WILD ARROW If Verbatim Then Verbatim WILD
##
## Ends in an error in state: 502.
##
## if_then_else(base_cond) -> If expr Then closed_if . Else base_cond [ With VBAR Type Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF Directive COLON Attr ]
##
## The known suffix of the stack is as follows:
## If expr Then closed_if
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 218, spurious reduction of production call_expr_level -> core_expr
## In state 224, spurious reduction of production unary_expr_level -> call_expr_level
## In state 205, spurious reduction of production mult_expr_level -> unary_expr_level
## In state 215, spurious reduction of production add_expr_level -> mult_expr_level
## In state 255, spurious reduction of production cons_expr_level -> add_expr_level
## In state 245, spurious reduction of production cat_expr_level -> cons_expr_level
## In state 277, spurious reduction of production comp_expr_level -> cat_expr_level
## In state 284, spurious reduction of production conj_expr_level -> comp_expr_level
## In state 291, spurious reduction of production disj_expr_level -> conj_expr_level
## In state 421, spurious reduction of production base_expr(closed_if) -> disj_expr_level
## In state 425, spurious reduction of production base_if_then_else__open(closed_if) -> base_expr(closed_if)
## In state 424, spurious reduction of production closed_if -> base_if_then_else__open(closed_if)
##
interactive_expr: If Verbatim Then If Verbatim Then Verbatim WILD
##
## Ends in an error in state: 625.
##
## if_then_else(closed_if) -> If expr Then closed_if . Else closed_if [ Else ]
## if_then_else(expr) -> If expr Then closed_if . Else expr [ With Type Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF Directive COLON Attr ]
##
## The known suffix of the stack is as follows:
## If expr Then closed_if
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 218, spurious reduction of production call_expr_level -> core_expr
## In state 224, spurious reduction of production unary_expr_level -> call_expr_level
## In state 205, spurious reduction of production mult_expr_level -> unary_expr_level
## In state 215, spurious reduction of production add_expr_level -> mult_expr_level
## In state 255, spurious reduction of production cons_expr_level -> add_expr_level
## In state 245, spurious reduction of production cat_expr_level -> cons_expr_level
## In state 277, spurious reduction of production comp_expr_level -> cat_expr_level
## In state 284, spurious reduction of production conj_expr_level -> comp_expr_level
## In state 291, spurious reduction of production disj_expr_level -> conj_expr_level
## In state 621, spurious reduction of production base_expr(closed_if) -> disj_expr_level
## In state 425, spurious reduction of production base_if_then_else__open(closed_if) -> base_expr(closed_if)
## In state 424, spurious reduction of production closed_if -> base_if_then_else__open(closed_if)
##
interactive_expr: If Verbatim Then Verbatim WILD
##
## Ends in an error in state: 628.
##
## if_then_else(expr) -> If expr Then closed_if . Else expr [ With Type Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF Directive COLON Attr ]
##
## The known suffix of the stack is as follows:
## If expr Then closed_if
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 218, spurious reduction of production call_expr_level -> core_expr
## In state 224, spurious reduction of production unary_expr_level -> call_expr_level
## In state 205, spurious reduction of production mult_expr_level -> unary_expr_level
## In state 215, spurious reduction of production add_expr_level -> mult_expr_level
## In state 255, spurious reduction of production cons_expr_level -> add_expr_level
## In state 245, spurious reduction of production cat_expr_level -> cons_expr_level
## In state 277, spurious reduction of production comp_expr_level -> cat_expr_level
## In state 284, spurious reduction of production conj_expr_level -> comp_expr_level
## In state 291, spurious reduction of production disj_expr_level -> conj_expr_level
## In state 621, spurious reduction of production base_expr(closed_if) -> disj_expr_level
## In state 425, spurious reduction of production base_if_then_else__open(closed_if) -> base_expr(closed_if)
## In state 424, spurious reduction of production closed_if -> base_if_then_else__open(closed_if)
##

Ill-formed complete conditional expression.
At this point, if the expression of the branch 'then' is complete, the
keyword 'else' is expected, followed by an expression.

interactive_expr: Begin If Verbatim Then If Verbatim With
##
## Ends in an error in state: 539.
##
## if_then_else(closed_if) -> If expr . Then closed_if Else closed_if [ Else ]
##
## The known suffix of the stack is as follows:
## If expr
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 218, spurious reduction of production call_expr_level -> core_expr
## In state 224, spurious reduction of production unary_expr_level -> call_expr_level
## In state 205, spurious reduction of production mult_expr_level -> unary_expr_level
## In state 215, spurious reduction of production add_expr_level -> mult_expr_level
## In state 255, spurious reduction of production cons_expr_level -> add_expr_level
## In state 245, spurious reduction of production cat_expr_level -> cons_expr_level
## In state 277, spurious reduction of production comp_expr_level -> cat_expr_level
## In state 284, spurious reduction of production conj_expr_level -> comp_expr_level
## In state 291, spurious reduction of production disj_expr_level -> conj_expr_level
## In state 243, spurious reduction of production base_expr(expr) -> disj_expr_level
## In state 297, spurious reduction of production base_cond__open(expr) -> base_expr(expr)
## In state 298, spurious reduction of production expr -> base_cond__open(expr)
##
interactive_expr: Begin If Verbatim With
##
## Ends in an error in state: 536.
##
## if_then_else(seq_expr) -> If expr . Then closed_if Else seq_expr [ SEMI End ]
##
## The known suffix of the stack is as follows:
## If expr
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 218, spurious reduction of production call_expr_level -> core_expr
## In state 224, spurious reduction of production unary_expr_level -> call_expr_level
## In state 205, spurious reduction of production mult_expr_level -> unary_expr_level
## In state 215, spurious reduction of production add_expr_level -> mult_expr_level
## In state 255, spurious reduction of production cons_expr_level -> add_expr_level
## In state 245, spurious reduction of production cat_expr_level -> cons_expr_level
## In state 277, spurious reduction of production comp_expr_level -> cat_expr_level
## In state 284, spurious reduction of production conj_expr_level -> comp_expr_level
## In state 291, spurious reduction of production disj_expr_level -> conj_expr_level
## In state 243, spurious reduction of production base_expr(expr) -> disj_expr_level
## In state 297, spurious reduction of production base_cond__open(expr) -> base_expr(expr)
## In state 298, spurious reduction of production expr -> base_cond__open(expr)
##
interactive_expr: Begin Match Verbatim With WILD ARROW If Verbatim With
##
## Ends in an error in state: 378.
##
## if_then(base_cond) -> If expr . Then base_cond [ VBAR ]
## if_then_else(base_cond) -> If expr . Then closed_if Else base_cond [ VBAR ]
## if_then_else(seq_expr) -> If expr . Then closed_if Else seq_expr [ SEMI End ]
##
## The known suffix of the stack is as follows:
## If expr
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 218, spurious reduction of production call_expr_level -> core_expr
## In state 224, spurious reduction of production unary_expr_level -> call_expr_level
## In state 205, spurious reduction of production mult_expr_level -> unary_expr_level
## In state 215, spurious reduction of production add_expr_level -> mult_expr_level
## In state 255, spurious reduction of production cons_expr_level -> add_expr_level
## In state 245, spurious reduction of production cat_expr_level -> cons_expr_level
## In state 277, spurious reduction of production comp_expr_level -> cat_expr_level
## In state 284, spurious reduction of production conj_expr_level -> comp_expr_level
## In state 291, spurious reduction of production disj_expr_level -> conj_expr_level
## In state 243, spurious reduction of production base_expr(expr) -> disj_expr_level
## In state 297, spurious reduction of production base_cond__open(expr) -> base_expr(expr)
## In state 298, spurious reduction of production expr -> base_cond__open(expr)
##
interactive_expr: If Verbatim Then If Verbatim With
##
## Ends in an error in state: 604.
##
## if_then(expr) -> If expr . Then expr [ With Type Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF Directive COLON Attr ]
## if_then_else(closed_if) -> If expr . Then closed_if Else closed_if [ Else ]
## if_then_else(expr) -> If expr . Then closed_if Else expr [ With Type Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF Directive COLON Attr ]
##
## The known suffix of the stack is as follows:
## If expr
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 218, spurious reduction of production call_expr_level -> core_expr
## In state 224, spurious reduction of production unary_expr_level -> call_expr_level
## In state 205, spurious reduction of production mult_expr_level -> unary_expr_level
## In state 215, spurious reduction of production add_expr_level -> mult_expr_level
## In state 255, spurious reduction of production cons_expr_level -> add_expr_level
## In state 245, spurious reduction of production cat_expr_level -> cons_expr_level
## In state 277, spurious reduction of production comp_expr_level -> cat_expr_level
## In state 284, spurious reduction of production conj_expr_level -> comp_expr_level
## In state 291, spurious reduction of production disj_expr_level -> conj_expr_level
## In state 243, spurious reduction of production base_expr(expr) -> disj_expr_level
## In state 297, spurious reduction of production base_cond__open(expr) -> base_expr(expr)
## In state 298, spurious reduction of production expr -> base_cond__open(expr)
##
interactive_expr: If Verbatim Then Match Verbatim With WILD ARROW If Verbatim With
##
## Ends in an error in state: 387.
##
## if_then(base_cond) -> If expr . Then base_cond [ With VBAR Type Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF Directive COLON Attr ]
## if_then_else(base_cond) -> If expr . Then closed_if Else base_cond [ With VBAR Type Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF Directive COLON Attr ]
## if_then_else(base_if_then_else) -> If expr . Then closed_if Else base_if_then_else [ Else ]
##
## The known suffix of the stack is as follows:
## If expr
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 218, spurious reduction of production call_expr_level -> core_expr
## In state 224, spurious reduction of production unary_expr_level -> call_expr_level
## In state 205, spurious reduction of production mult_expr_level -> unary_expr_level
## In state 215, spurious reduction of production add_expr_level -> mult_expr_level
## In state 255, spurious reduction of production cons_expr_level -> add_expr_level
## In state 245, spurious reduction of production cat_expr_level -> cons_expr_level
## In state 277, spurious reduction of production comp_expr_level -> cat_expr_level
## In state 284, spurious reduction of production conj_expr_level -> comp_expr_level
## In state 291, spurious reduction of production disj_expr_level -> conj_expr_level
## In state 243, spurious reduction of production base_expr(expr) -> disj_expr_level
## In state 297, spurious reduction of production base_cond__open(expr) -> base_expr(expr)
## In state 298, spurious reduction of production expr -> base_cond__open(expr)
##
interactive_expr: If Verbatim With
##
## Ends in an error in state: 596.
##
## if_then(expr) -> If expr . Then expr [ With Type Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF Directive COLON Attr ]
## if_then_else(expr) -> If expr . Then closed_if Else expr [ With Type Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF Directive COLON Attr ]
##
## The known suffix of the stack is as follows:
## If expr
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 218, spurious reduction of production call_expr_level -> core_expr
## In state 224, spurious reduction of production unary_expr_level -> call_expr_level
## In state 205, spurious reduction of production mult_expr_level -> unary_expr_level
## In state 215, spurious reduction of production add_expr_level -> mult_expr_level
## In state 255, spurious reduction of production cons_expr_level -> add_expr_level
## In state 245, spurious reduction of production cat_expr_level -> cons_expr_level
## In state 277, spurious reduction of production comp_expr_level -> cat_expr_level
## In state 284, spurious reduction of production conj_expr_level -> comp_expr_level
## In state 291, spurious reduction of production disj_expr_level -> conj_expr_level
## In state 243, spurious reduction of production base_expr(expr) -> disj_expr_level
## In state 297, spurious reduction of production base_cond__open(expr) -> base_expr(expr)
## In state 298, spurious reduction of production expr -> base_cond__open(expr)
##
interactive_expr: Match Verbatim With WILD ARROW If Verbatim Then If Verbatim With
##
## Ends in an error in state: 390.
##
## if_then(base_cond) -> If expr . Then base_cond [ With VBAR Type Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF Directive COLON Attr ]
## if_then_else(base_cond) -> If expr . Then closed_if Else base_cond [ With VBAR Type Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF Directive COLON Attr ]
## if_then_else(closed_if) -> If expr . Then closed_if Else closed_if [ Else ]
##
## The known suffix of the stack is as follows:
## If expr
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 218, spurious reduction of production call_expr_level -> core_expr
## In state 224, spurious reduction of production unary_expr_level -> call_expr_level
## In state 205, spurious reduction of production mult_expr_level -> unary_expr_level
## In state 215, spurious reduction of production add_expr_level -> mult_expr_level
## In state 255, spurious reduction of production cons_expr_level -> add_expr_level
## In state 245, spurious reduction of production cat_expr_level -> cons_expr_level
## In state 277, spurious reduction of production comp_expr_level -> cat_expr_level
## In state 284, spurious reduction of production conj_expr_level -> comp_expr_level
## In state 291, spurious reduction of production disj_expr_level -> conj_expr_level
## In state 243, spurious reduction of production base_expr(expr) -> disj_expr_level
## In state 297, spurious reduction of production base_cond__open(expr) -> base_expr(expr)
## In state 298, spurious reduction of production expr -> base_cond__open(expr)
##
interactive_expr: Match Verbatim With WILD ARROW If Verbatim With
##
## Ends in an error in state: 500.
##
## if_then(base_cond) -> If expr . Then base_cond [ With VBAR Type Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF Directive COLON Attr ]
## if_then_else(base_cond) -> If expr . Then closed_if Else base_cond [ With VBAR Type Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF Directive COLON Attr ]
##
## The known suffix of the stack is as follows:
## If expr
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 218, spurious reduction of production call_expr_level -> core_expr
## In state 224, spurious reduction of production unary_expr_level -> call_expr_level
## In state 205, spurious reduction of production mult_expr_level -> unary_expr_level
## In state 215, spurious reduction of production add_expr_level -> mult_expr_level
## In state 255, spurious reduction of production cons_expr_level -> add_expr_level
## In state 245, spurious reduction of production cat_expr_level -> cons_expr_level
## In state 277, spurious reduction of production comp_expr_level -> cat_expr_level
## In state 284, spurious reduction of production conj_expr_level -> comp_expr_level
## In state 291, spurious reduction of production disj_expr_level -> conj_expr_level
## In state 243, spurious reduction of production base_expr(expr) -> disj_expr_level
## In state 297, spurious reduction of production base_cond__open(expr) -> base_expr(expr)
## In state 298, spurious reduction of production expr -> base_cond__open(expr)
##

Ill-formed conditional expression.
At this point, if the condition is complete, the keyword 'then' is
expected, followed by an expression.

interactive_expr: Begin If Verbatim Then Let Rec WILD EQ Bytes With
##
## Ends in an error in state: 550.
##
## let_expr(closed_if) -> seq(Attr) Let Rec let_binding . In closed_if [ Else ]
##
## The known suffix of the stack is as follows:
## seq(Attr) Let Rec let_binding
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 218, spurious reduction of production call_expr_level -> core_expr
## In state 224, spurious reduction of production unary_expr_level -> call_expr_level
## In state 205, spurious reduction of production mult_expr_level -> unary_expr_level
## In state 215, spurious reduction of production add_expr_level -> mult_expr_level
## In state 255, spurious reduction of production cons_expr_level -> add_expr_level
## In state 245, spurious reduction of production cat_expr_level -> cons_expr_level
## In state 277, spurious reduction of production comp_expr_level -> cat_expr_level
## In state 284, spurious reduction of production conj_expr_level -> comp_expr_level
## In state 291, spurious reduction of production disj_expr_level -> conj_expr_level
## In state 243, spurious reduction of production base_expr(expr) -> disj_expr_level
## In state 297, spurious reduction of production base_cond__open(expr) -> base_expr(expr)
## In state 298, spurious reduction of production expr -> base_cond__open(expr)
## In state 304, spurious reduction of production let_binding -> irrefutable option(type_annotation) EQ expr
##
interactive_expr: Begin Let Rec WILD EQ Bytes With
##
## Ends in an error in state: 571.
##
## let_in_sequence -> seq(Attr) Let Rec let_binding . In series [ End ]
##
## The known suffix of the stack is as follows:
## seq(Attr) Let Rec let_binding
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 218, spurious reduction of production call_expr_level -> core_expr
## In state 224, spurious reduction of production unary_expr_level -> call_expr_level
## In state 205, spurious reduction of production mult_expr_level -> unary_expr_level
## In state 215, spurious reduction of production add_expr_level -> mult_expr_level
## In state 255, spurious reduction of production cons_expr_level -> add_expr_level
## In state 245, spurious reduction of production cat_expr_level -> cons_expr_level
## In state 277, spurious reduction of production comp_expr_level -> cat_expr_level
## In state 284, spurious reduction of production conj_expr_level -> comp_expr_level
## In state 291, spurious reduction of production disj_expr_level -> conj_expr_level
## In state 243, spurious reduction of production base_expr(expr) -> disj_expr_level
## In state 297, spurious reduction of production base_cond__open(expr) -> base_expr(expr)
## In state 298, spurious reduction of production expr -> base_cond__open(expr)
## In state 304, spurious reduction of production let_binding -> irrefutable option(type_annotation) EQ expr
##
interactive_expr: Begin Match Verbatim With WILD ARROW Let Rec WILD EQ Bytes With
##
## Ends in an error in state: 530.
##
## let_expr(base_cond) -> seq(Attr) Let Rec let_binding . In base_cond [ VBAR ]
## let_in_sequence -> seq(Attr) Let Rec let_binding . In series [ End ]
##
## The known suffix of the stack is as follows:
## seq(Attr) Let Rec let_binding
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 218, spurious reduction of production call_expr_level -> core_expr
## In state 224, spurious reduction of production unary_expr_level -> call_expr_level
## In state 205, spurious reduction of production mult_expr_level -> unary_expr_level
## In state 215, spurious reduction of production add_expr_level -> mult_expr_level
## In state 255, spurious reduction of production cons_expr_level -> add_expr_level
## In state 245, spurious reduction of production cat_expr_level -> cons_expr_level
## In state 277, spurious reduction of production comp_expr_level -> cat_expr_level
## In state 284, spurious reduction of production conj_expr_level -> comp_expr_level
## In state 291, spurious reduction of production disj_expr_level -> conj_expr_level
## In state 243, spurious reduction of production base_expr(expr) -> disj_expr_level
## In state 297, spurious reduction of production base_cond__open(expr) -> base_expr(expr)
## In state 298, spurious reduction of production expr -> base_cond__open(expr)
## In state 304, spurious reduction of production let_binding -> irrefutable option(type_annotation) EQ expr
##
interactive_expr: If Verbatim Then Let Rec WILD EQ Bytes With
##
## Ends in an error in state: 615.
##
## let_expr(closed_if) -> seq(Attr) Let Rec let_binding . In closed_if [ Else ]
## let_expr(expr) -> seq(Attr) Let Rec let_binding . In expr [ With Type Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF Directive COLON Attr ]
##
## The known suffix of the stack is as follows:
## seq(Attr) Let Rec let_binding
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 218, spurious reduction of production call_expr_level -> core_expr
## In state 224, spurious reduction of production unary_expr_level -> call_expr_level
## In state 205, spurious reduction of production mult_expr_level -> unary_expr_level
## In state 215, spurious reduction of production add_expr_level -> mult_expr_level
## In state 255, spurious reduction of production cons_expr_level -> add_expr_level
## In state 245, spurious reduction of production cat_expr_level -> cons_expr_level
## In state 277, spurious reduction of production comp_expr_level -> cat_expr_level
## In state 284, spurious reduction of production conj_expr_level -> comp_expr_level
## In state 291, spurious reduction of production disj_expr_level -> conj_expr_level
## In state 243, spurious reduction of production base_expr(expr) -> disj_expr_level
## In state 297, spurious reduction of production base_cond__open(expr) -> base_expr(expr)
## In state 298, spurious reduction of production expr -> base_cond__open(expr)
## In state 304, spurious reduction of production let_binding -> irrefutable option(type_annotation) EQ expr
##
interactive_expr: If Verbatim Then Match Verbatim With WILD ARROW Let Rec WILD EQ Bytes With
##
## Ends in an error in state: 461.
##
## let_expr(base_cond) -> seq(Attr) Let Rec let_binding . In base_cond [ With VBAR Type Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF Directive COLON Attr ]
## let_expr(base_if_then_else) -> seq(Attr) Let Rec let_binding . In base_if_then_else [ Else ]
##
## The known suffix of the stack is as follows:
## seq(Attr) Let Rec let_binding
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 218, spurious reduction of production call_expr_level -> core_expr
## In state 224, spurious reduction of production unary_expr_level -> call_expr_level
## In state 205, spurious reduction of production mult_expr_level -> unary_expr_level
## In state 215, spurious reduction of production add_expr_level -> mult_expr_level
## In state 255, spurious reduction of production cons_expr_level -> add_expr_level
## In state 245, spurious reduction of production cat_expr_level -> cons_expr_level
## In state 277, spurious reduction of production comp_expr_level -> cat_expr_level
## In state 284, spurious reduction of production conj_expr_level -> comp_expr_level
## In state 291, spurious reduction of production disj_expr_level -> conj_expr_level
## In state 243, spurious reduction of production base_expr(expr) -> disj_expr_level
## In state 297, spurious reduction of production base_cond__open(expr) -> base_expr(expr)
## In state 298, spurious reduction of production expr -> base_cond__open(expr)
## In state 304, spurious reduction of production let_binding -> irrefutable option(type_annotation) EQ expr
##
interactive_expr: Let Rec WILD EQ Bytes With
##
## Ends in an error in state: 213.
##
## let_expr(expr) -> seq(Attr) Let Rec let_binding . In expr [ With Type Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF Directive COLON Attr ]
##
## The known suffix of the stack is as follows:
## seq(Attr) Let Rec let_binding
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 218, spurious reduction of production call_expr_level -> core_expr
## In state 224, spurious reduction of production unary_expr_level -> call_expr_level
## In state 205, spurious reduction of production mult_expr_level -> unary_expr_level
## In state 215, spurious reduction of production add_expr_level -> mult_expr_level
## In state 255, spurious reduction of production cons_expr_level -> add_expr_level
## In state 245, spurious reduction of production cat_expr_level -> cons_expr_level
## In state 277, spurious reduction of production comp_expr_level -> cat_expr_level
## In state 284, spurious reduction of production conj_expr_level -> comp_expr_level
## In state 291, spurious reduction of production disj_expr_level -> conj_expr_level
## In state 243, spurious reduction of production base_expr(expr) -> disj_expr_level
## In state 297, spurious reduction of production base_cond__open(expr) -> base_expr(expr)
## In state 298, spurious reduction of production expr -> base_cond__open(expr)
## In state 304, spurious reduction of production let_binding -> irrefutable option(type_annotation) EQ expr
##
interactive_expr: Match Verbatim With WILD ARROW If Verbatim Then Let Rec WILD EQ Bytes With
##
## Ends in an error in state: 401.
##
## let_expr(base_cond) -> seq(Attr) Let Rec let_binding . In base_cond [ With VBAR Type Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF Directive COLON Attr ]
## let_expr(closed_if) -> seq(Attr) Let Rec let_binding . In closed_if [ Else ]
##
## The known suffix of the stack is as follows:
## seq(Attr) Let Rec let_binding
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 218, spurious reduction of production call_expr_level -> core_expr
## In state 224, spurious reduction of production unary_expr_level -> call_expr_level
## In state 205, spurious reduction of production mult_expr_level -> unary_expr_level
## In state 215, spurious reduction of production add_expr_level -> mult_expr_level
## In state 255, spurious reduction of production cons_expr_level -> add_expr_level
## In state 245, spurious reduction of production cat_expr_level -> cons_expr_level
## In state 277, spurious reduction of production comp_expr_level -> cat_expr_level
## In state 284, spurious reduction of production conj_expr_level -> comp_expr_level
## In state 291, spurious reduction of production disj_expr_level -> conj_expr_level
## In state 243, spurious reduction of production base_expr(expr) -> disj_expr_level
## In state 297, spurious reduction of production base_cond__open(expr) -> base_expr(expr)
## In state 298, spurious reduction of production expr -> base_cond__open(expr)
## In state 304, spurious reduction of production let_binding -> irrefutable option(type_annotation) EQ expr
##
interactive_expr: Match Verbatim With WILD ARROW Let Rec WILD EQ Bytes With
##
## Ends in an error in state: 510.
##
## let_expr(base_cond) -> seq(Attr) Let Rec let_binding . In base_cond [ With VBAR Type Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF Directive COLON Attr ]
##
## The known suffix of the stack is as follows:
## seq(Attr) Let Rec let_binding
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 218, spurious reduction of production call_expr_level -> core_expr
## In state 224, spurious reduction of production unary_expr_level -> call_expr_level
## In state 205, spurious reduction of production mult_expr_level -> unary_expr_level
## In state 215, spurious reduction of production add_expr_level -> mult_expr_level
## In state 255, spurious reduction of production cons_expr_level -> add_expr_level
## In state 245, spurious reduction of production cat_expr_level -> cons_expr_level
## In state 277, spurious reduction of production comp_expr_level -> cat_expr_level
## In state 284, spurious reduction of production conj_expr_level -> comp_expr_level
## In state 291, spurious reduction of production disj_expr_level -> conj_expr_level
## In state 243, spurious reduction of production base_expr(expr) -> disj_expr_level
## In state 297, spurious reduction of production base_cond__open(expr) -> base_expr(expr)
## In state 298, spurious reduction of production expr -> base_cond__open(expr)
## In state 304, spurious reduction of production let_binding -> irrefutable option(type_annotation) EQ expr
##
interactive_expr: Begin If Verbatim Then Let WILD EQ Bytes With
##
## Ends in an error in state: 557.
##
## let_expr(closed_if) -> seq(Attr) Let let_binding . In closed_if [ Else ]
##
## The known suffix of the stack is as follows:
## seq(Attr) Let let_binding
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 218, spurious reduction of production call_expr_level -> core_expr
## In state 224, spurious reduction of production unary_expr_level -> call_expr_level
## In state 205, spurious reduction of production mult_expr_level -> unary_expr_level
## In state 215, spurious reduction of production add_expr_level -> mult_expr_level
## In state 255, spurious reduction of production cons_expr_level -> add_expr_level
## In state 245, spurious reduction of production cat_expr_level -> cons_expr_level
## In state 277, spurious reduction of production comp_expr_level -> cat_expr_level
## In state 284, spurious reduction of production conj_expr_level -> comp_expr_level
## In state 291, spurious reduction of production disj_expr_level -> conj_expr_level
## In state 243, spurious reduction of production base_expr(expr) -> disj_expr_level
## In state 297, spurious reduction of production base_cond__open(expr) -> base_expr(expr)
## In state 298, spurious reduction of production expr -> base_cond__open(expr)
## In state 304, spurious reduction of production let_binding -> irrefutable option(type_annotation) EQ expr
##
interactive_expr: Begin Let WILD EQ Bytes With
##
## Ends in an error in state: 578.
##
## let_in_sequence -> seq(Attr) Let let_binding . In series [ End ]
##
## The known suffix of the stack is as follows:
## seq(Attr) Let let_binding
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 218, spurious reduction of production call_expr_level -> core_expr
## In state 224, spurious reduction of production unary_expr_level -> call_expr_level
## In state 205, spurious reduction of production mult_expr_level -> unary_expr_level
## In state 215, spurious reduction of production add_expr_level -> mult_expr_level
## In state 255, spurious reduction of production cons_expr_level -> add_expr_level
## In state 245, spurious reduction of production cat_expr_level -> cons_expr_level
## In state 277, spurious reduction of production comp_expr_level -> cat_expr_level
## In state 284, spurious reduction of production conj_expr_level -> comp_expr_level
## In state 291, spurious reduction of production disj_expr_level -> conj_expr_level
## In state 243, spurious reduction of production base_expr(expr) -> disj_expr_level
## In state 297, spurious reduction of production base_cond__open(expr) -> base_expr(expr)
## In state 298, spurious reduction of production expr -> base_cond__open(expr)
## In state 304, spurious reduction of production let_binding -> irrefutable option(type_annotation) EQ expr
##
interactive_expr: Begin Match Verbatim With WILD ARROW Let WILD EQ Bytes With
##
## Ends in an error in state: 583.
##
## let_expr(base_cond) -> seq(Attr) Let let_binding . In base_cond [ VBAR ]
## let_in_sequence -> seq(Attr) Let let_binding . In series [ End ]
##
## The known suffix of the stack is as follows:
## seq(Attr) Let let_binding
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 218, spurious reduction of production call_expr_level -> core_expr
## In state 224, spurious reduction of production unary_expr_level -> call_expr_level
## In state 205, spurious reduction of production mult_expr_level -> unary_expr_level
## In state 215, spurious reduction of production add_expr_level -> mult_expr_level
## In state 255, spurious reduction of production cons_expr_level -> add_expr_level
## In state 245, spurious reduction of production cat_expr_level -> cons_expr_level
## In state 277, spurious reduction of production comp_expr_level -> cat_expr_level
## In state 284, spurious reduction of production conj_expr_level -> comp_expr_level
## In state 291, spurious reduction of production disj_expr_level -> conj_expr_level
## In state 243, spurious reduction of production base_expr(expr) -> disj_expr_level
## In state 297, spurious reduction of production base_cond__open(expr) -> base_expr(expr)
## In state 298, spurious reduction of production expr -> base_cond__open(expr)
## In state 304, spurious reduction of production let_binding -> irrefutable option(type_annotation) EQ expr
##
interactive_expr: If Verbatim Then Match Verbatim With WILD ARROW Let WILD EQ Bytes With
##
## Ends in an error in state: 479.
##
## let_expr(base_cond) -> seq(Attr) Let let_binding . In base_cond [ With VBAR Type Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF Directive COLON Attr ]
## let_expr(base_if_then_else) -> seq(Attr) Let let_binding . In base_if_then_else [ Else ]
##
## The known suffix of the stack is as follows:
## seq(Attr) Let let_binding
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 218, spurious reduction of production call_expr_level -> core_expr
## In state 224, spurious reduction of production unary_expr_level -> call_expr_level
## In state 205, spurious reduction of production mult_expr_level -> unary_expr_level
## In state 215, spurious reduction of production add_expr_level -> mult_expr_level
## In state 255, spurious reduction of production cons_expr_level -> add_expr_level
## In state 245, spurious reduction of production cat_expr_level -> cons_expr_level
## In state 277, spurious reduction of production comp_expr_level -> cat_expr_level
## In state 284, spurious reduction of production conj_expr_level -> comp_expr_level
## In state 291, spurious reduction of production disj_expr_level -> conj_expr_level
## In state 243, spurious reduction of production base_expr(expr) -> disj_expr_level
## In state 297, spurious reduction of production base_cond__open(expr) -> base_expr(expr)
## In state 298, spurious reduction of production expr -> base_cond__open(expr)
## In state 304, spurious reduction of production let_binding -> irrefutable option(type_annotation) EQ expr
##
interactive_expr: If Verbatim Then Let WILD EQ Bytes With
##
## Ends in an error in state: 622.
##
## let_expr(closed_if) -> seq(Attr) Let let_binding . In closed_if [ Else ]
## let_expr(expr) -> seq(Attr) Let let_binding . In expr [ With Type Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF Directive COLON Attr ]
##
## The known suffix of the stack is as follows:
## seq(Attr) Let let_binding
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 218, spurious reduction of production call_expr_level -> core_expr
## In state 224, spurious reduction of production unary_expr_level -> call_expr_level
## In state 205, spurious reduction of production mult_expr_level -> unary_expr_level
## In state 215, spurious reduction of production add_expr_level -> mult_expr_level
## In state 255, spurious reduction of production cons_expr_level -> add_expr_level
## In state 245, spurious reduction of production cat_expr_level -> cons_expr_level
## In state 277, spurious reduction of production comp_expr_level -> cat_expr_level
## In state 284, spurious reduction of production conj_expr_level -> comp_expr_level
## In state 291, spurious reduction of production disj_expr_level -> conj_expr_level
## In state 243, spurious reduction of production base_expr(expr) -> disj_expr_level
## In state 297, spurious reduction of production base_cond__open(expr) -> base_expr(expr)
## In state 298, spurious reduction of production expr -> base_cond__open(expr)
## In state 304, spurious reduction of production let_binding -> irrefutable option(type_annotation) EQ expr
##
interactive_expr: Let WILD EQ Bytes With
##
## Ends in an error in state: 305.
##
## let_expr(expr) -> seq(Attr) Let let_binding . In expr [ With Type Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF Directive COLON Attr ]
##
## The known suffix of the stack is as follows:
## seq(Attr) Let let_binding
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 218, spurious reduction of production call_expr_level -> core_expr
## In state 224, spurious reduction of production unary_expr_level -> call_expr_level
## In state 205, spurious reduction of production mult_expr_level -> unary_expr_level
## In state 215, spurious reduction of production add_expr_level -> mult_expr_level
## In state 255, spurious reduction of production cons_expr_level -> add_expr_level
## In state 245, spurious reduction of production cat_expr_level -> cons_expr_level
## In state 277, spurious reduction of production comp_expr_level -> cat_expr_level
## In state 284, spurious reduction of production conj_expr_level -> comp_expr_level
## In state 291, spurious reduction of production disj_expr_level -> conj_expr_level
## In state 243, spurious reduction of production base_expr(expr) -> disj_expr_level
## In state 297, spurious reduction of production base_cond__open(expr) -> base_expr(expr)
## In state 298, spurious reduction of production expr -> base_cond__open(expr)
## In state 304, spurious reduction of production let_binding -> irrefutable option(type_annotation) EQ expr
##
interactive_expr: Match Verbatim With WILD ARROW If Verbatim Then Let WILD EQ Bytes With
##
## Ends in an error in state: 433.
##
## let_expr(base_cond) -> seq(Attr) Let let_binding . In base_cond [ With VBAR Type Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF Directive COLON Attr ]
## let_expr(closed_if) -> seq(Attr) Let let_binding . In closed_if [ Else ]
##
## The known suffix of the stack is as follows:
## seq(Attr) Let let_binding
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 218, spurious reduction of production call_expr_level -> core_expr
## In state 224, spurious reduction of production unary_expr_level -> call_expr_level
## In state 205, spurious reduction of production mult_expr_level -> unary_expr_level
## In state 215, spurious reduction of production add_expr_level -> mult_expr_level
## In state 255, spurious reduction of production cons_expr_level -> add_expr_level
## In state 245, spurious reduction of production cat_expr_level -> cons_expr_level
## In state 277, spurious reduction of production comp_expr_level -> cat_expr_level
## In state 284, spurious reduction of production conj_expr_level -> comp_expr_level
## In state 291, spurious reduction of production disj_expr_level -> conj_expr_level
## In state 243, spurious reduction of production base_expr(expr) -> disj_expr_level
## In state 297, spurious reduction of production base_cond__open(expr) -> base_expr(expr)
## In state 298, spurious reduction of production expr -> base_cond__open(expr)
## In state 304, spurious reduction of production let_binding -> irrefutable option(type_annotation) EQ expr
##
interactive_expr: Match Verbatim With WILD ARROW Let WILD EQ Bytes With
##
## Ends in an error in state: 517.
##
## let_expr(base_cond) -> seq(Attr) Let let_binding . In base_cond [ With VBAR Type Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF Directive COLON Attr ]
##
## The known suffix of the stack is as follows:
## seq(Attr) Let let_binding
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 218, spurious reduction of production call_expr_level -> core_expr
## In state 224, spurious reduction of production unary_expr_level -> call_expr_level
## In state 205, spurious reduction of production mult_expr_level -> unary_expr_level
## In state 215, spurious reduction of production add_expr_level -> mult_expr_level
## In state 255, spurious reduction of production cons_expr_level -> add_expr_level
## In state 245, spurious reduction of production cat_expr_level -> cons_expr_level
## In state 277, spurious reduction of production comp_expr_level -> cat_expr_level
## In state 284, spurious reduction of production conj_expr_level -> comp_expr_level
## In state 291, spurious reduction of production disj_expr_level -> conj_expr_level
## In state 243, spurious reduction of production base_expr(expr) -> disj_expr_level
## In state 297, spurious reduction of production base_cond__open(expr) -> base_expr(expr)
## In state 298, spurious reduction of production expr -> base_cond__open(expr)
## In state 304, spurious reduction of production let_binding -> irrefutable option(type_annotation) EQ expr
##

Ill-formed value declaration.
At this point, if the right-hand side of the declaration is a complete
expression, the keyword 'in' is expected, followed by an expression.

interactive_expr: Begin If Verbatim Then Let Rec With
##
## Ends in an error in state: 549.
##
## let_expr(closed_if) -> seq(Attr) Let Rec . let_binding In closed_if [ Else ]
##
## The known suffix of the stack is as follows:
## seq(Attr) Let Rec
##
interactive_expr: Begin Match Verbatim With WILD ARROW Let Rec With
##
## Ends in an error in state: 529.
##
## let_expr(base_cond) -> seq(Attr) Let Rec . let_binding In base_cond [ VBAR ]
## let_in_sequence -> seq(Attr) Let Rec . let_binding In series [ End ]
##
## The known suffix of the stack is as follows:
## seq(Attr) Let Rec
##
interactive_expr: Begin Let Rec With
##
## Ends in an error in state: 570.
##
## let_in_sequence -> seq(Attr) Let Rec . let_binding In series [ End ]
##
## The known suffix of the stack is as follows:
## seq(Attr) Let Rec
##
interactive_expr: If Verbatim Then Let Rec With
##
## Ends in an error in state: 614.
##
## let_expr(closed_if) -> seq(Attr) Let Rec . let_binding In closed_if [ Else ]
## let_expr(expr) -> seq(Attr) Let Rec . let_binding In expr [ With Type Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF Directive COLON Attr ]
##
## The known suffix of the stack is as follows:
## seq(Attr) Let Rec
##
interactive_expr: If Verbatim Then Match Verbatim With WILD ARROW Let Rec With
##
## Ends in an error in state: 460.
##
## let_expr(base_cond) -> seq(Attr) Let Rec . let_binding In base_cond [ With VBAR Type Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF Directive COLON Attr ]
## let_expr(base_if_then_else) -> seq(Attr) Let Rec . let_binding In base_if_then_else [ Else ]
##
## The known suffix of the stack is as follows:
## seq(Attr) Let Rec
##
interactive_expr: Let Rec With
##
## Ends in an error in state: 212.
##
## let_expr(expr) -> seq(Attr) Let Rec . let_binding In expr [ With Type Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF Directive COLON Attr ]
##
## The known suffix of the stack is as follows:
## seq(Attr) Let Rec
##
interactive_expr: Match Verbatim With WILD ARROW If Verbatim Then Let Rec With
##
## Ends in an error in state: 400.
##
## let_expr(base_cond) -> seq(Attr) Let Rec . let_binding In base_cond [ With VBAR Type Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF Directive COLON Attr ]
## let_expr(closed_if) -> seq(Attr) Let Rec . let_binding In closed_if [ Else ]
##
## The known suffix of the stack is as follows:
## seq(Attr) Let Rec
##
interactive_expr: Match Verbatim With WILD ARROW Let Rec With
##
## Ends in an error in state: 509.
##
## let_expr(base_cond) -> seq(Attr) Let Rec . let_binding In base_cond [ With VBAR Type Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF Directive COLON Attr ]
##
## The known suffix of the stack is as follows:
## seq(Attr) Let Rec
##
contract: Let Rec With
##
## Ends in an error in state: 97.
##
## let_declaration -> seq(Attr) Let Rec . let_binding [ Type Module Let End EOF Directive Attr ]
##
## The known suffix of the stack is as follows:
## seq(Attr) Let Rec
##

Ill-formed recursive value declaration.
At this point, an irrefutable pattern is expected, for instance an
identifier for the value being defined.

interactive_expr: Begin If Verbatim Then Let With
##
## Ends in an error in state: 548.
##
## let_expr(closed_if) -> seq(Attr) Let . let_binding In closed_if [ Else ]
## let_expr(closed_if) -> seq(Attr) Let . Rec let_binding In closed_if [ Else ]
##
## The known suffix of the stack is as follows:
## seq(Attr) Let
##
interactive_expr: Begin Let With
##
## Ends in an error in state: 569.
##
## let_in_sequence -> seq(Attr) Let . let_binding In series [ End ]
## let_in_sequence -> seq(Attr) Let . Rec let_binding In series [ End ]
##
## The known suffix of the stack is as follows:
## seq(Attr) Let
##
interactive_expr: Begin Match Verbatim With WILD ARROW Let With
##
## Ends in an error in state: 528.
##
## let_expr(base_cond) -> seq(Attr) Let . let_binding In base_cond [ VBAR ]
## let_expr(base_cond) -> seq(Attr) Let . Rec let_binding In base_cond [ VBAR ]
## let_in_sequence -> seq(Attr) Let . let_binding In series [ End ]
## let_in_sequence -> seq(Attr) Let . Rec let_binding In series [ End ]
##
## The known suffix of the stack is as follows:
## seq(Attr) Let
##
interactive_expr: If Verbatim Then Match Verbatim With WILD ARROW Let With
##
## Ends in an error in state: 459.
##
## let_expr(base_cond) -> seq(Attr) Let . let_binding In base_cond [ With VBAR Type Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF Directive COLON Attr ]
## let_expr(base_cond) -> seq(Attr) Let . Rec let_binding In base_cond [ With VBAR Type Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF Directive COLON Attr ]
## let_expr(base_if_then_else) -> seq(Attr) Let . let_binding In base_if_then_else [ Else ]
## let_expr(base_if_then_else) -> seq(Attr) Let . Rec let_binding In base_if_then_else [ Else ]
##
## The known suffix of the stack is as follows:
## seq(Attr) Let
##
interactive_expr: If Verbatim Then Let With
##
## Ends in an error in state: 613.
##
## let_expr(closed_if) -> seq(Attr) Let . let_binding In closed_if [ Else ]
## let_expr(closed_if) -> seq(Attr) Let . Rec let_binding In closed_if [ Else ]
## let_expr(expr) -> seq(Attr) Let . let_binding In expr [ With Type Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF Directive COLON Attr ]
## let_expr(expr) -> seq(Attr) Let . Rec let_binding In expr [ With Type Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF Directive COLON Attr ]
##
## The known suffix of the stack is as follows:
## seq(Attr) Let
##
interactive_expr: Let With
##
## Ends in an error in state: 211.
##
## let_expr(expr) -> seq(Attr) Let . let_binding In expr [ With Type Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF Directive COLON Attr ]
## let_expr(expr) -> seq(Attr) Let . Rec let_binding In expr [ With Type Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF Directive COLON Attr ]
##
## The known suffix of the stack is as follows:
## seq(Attr) Let
##
interactive_expr: Match Verbatim With WILD ARROW If Verbatim Then Let With
##
## Ends in an error in state: 399.
##
## let_expr(base_cond) -> seq(Attr) Let . let_binding In base_cond [ With VBAR Type Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF Directive COLON Attr ]
## let_expr(base_cond) -> seq(Attr) Let . Rec let_binding In base_cond [ With VBAR Type Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF Directive COLON Attr ]
## let_expr(closed_if) -> seq(Attr) Let . let_binding In closed_if [ Else ]
## let_expr(closed_if) -> seq(Attr) Let . Rec let_binding In closed_if [ Else ]
##
## The known suffix of the stack is as follows:
## seq(Attr) Let
##
interactive_expr: Match Verbatim With WILD ARROW Let With
##
## Ends in an error in state: 508.
##
## let_expr(base_cond) -> seq(Attr) Let . let_binding In base_cond [ With VBAR Type Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF Directive COLON Attr ]
## let_expr(base_cond) -> seq(Attr) Let . Rec let_binding In base_cond [ With VBAR Type Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF Directive COLON Attr ]
##
## The known suffix of the stack is as follows:
## seq(Attr) Let
##
contract: Let With
##
## Ends in an error in state: 95.
##
## let_declaration -> seq(Attr) Let . let_binding [ Type Module Let End EOF Directive Attr ]
## let_declaration -> seq(Attr) Let . Rec let_binding [ Type Module Let End EOF Directive Attr ]
##
## The known suffix of the stack is as follows:
## seq(Attr) Let
##

Ill-formed value declaration.
At this point, one of the following is expected:
  * an irrefutable pattern, for instance an identifier denoting the
    value being defined;
  * the 'rec' keyword if the declaration is recursive.

interactive_expr: Begin If Verbatim Then Match Verbatim Type
##
## Ends in an error in state: 381.
##
## match_expr(base_if_then_else) -> Match expr . With option(VBAR) cases(base_if_then_else) [ Else ]
##
## The known suffix of the stack is as follows:
## Match expr
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 218, spurious reduction of production call_expr_level -> core_expr
## In state 224, spurious reduction of production unary_expr_level -> call_expr_level
## In state 205, spurious reduction of production mult_expr_level -> unary_expr_level
## In state 215, spurious reduction of production add_expr_level -> mult_expr_level
## In state 255, spurious reduction of production cons_expr_level -> add_expr_level
## In state 245, spurious reduction of production cat_expr_level -> cons_expr_level
## In state 277, spurious reduction of production comp_expr_level -> cat_expr_level
## In state 284, spurious reduction of production conj_expr_level -> comp_expr_level
## In state 291, spurious reduction of production disj_expr_level -> conj_expr_level
## In state 243, spurious reduction of production base_expr(expr) -> disj_expr_level
## In state 297, spurious reduction of production base_cond__open(expr) -> base_expr(expr)
## In state 298, spurious reduction of production expr -> base_cond__open(expr)
##
interactive_expr: Begin Match Verbatim Type
##
## Ends in an error in state: 309.
##
## match_expr(last_expr) -> Match expr . With option(VBAR) cases(last_expr) [ End ]
##
## The known suffix of the stack is as follows:
## Match expr
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 218, spurious reduction of production call_expr_level -> core_expr
## In state 224, spurious reduction of production unary_expr_level -> call_expr_level
## In state 205, spurious reduction of production mult_expr_level -> unary_expr_level
## In state 215, spurious reduction of production add_expr_level -> mult_expr_level
## In state 255, spurious reduction of production cons_expr_level -> add_expr_level
## In state 245, spurious reduction of production cat_expr_level -> cons_expr_level
## In state 277, spurious reduction of production comp_expr_level -> cat_expr_level
## In state 284, spurious reduction of production conj_expr_level -> comp_expr_level
## In state 291, spurious reduction of production disj_expr_level -> conj_expr_level
## In state 243, spurious reduction of production base_expr(expr) -> disj_expr_level
## In state 297, spurious reduction of production base_cond__open(expr) -> base_expr(expr)
## In state 298, spurious reduction of production expr -> base_cond__open(expr)
##
interactive_expr: Match Verbatim Type
##
## Ends in an error in state: 680.
##
## match_expr(base_cond) -> Match expr . With option(VBAR) cases(base_cond) [ With Type Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF Directive COLON Attr ]
##
## The known suffix of the stack is as follows:
## Match expr
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 218, spurious reduction of production call_expr_level -> core_expr
## In state 224, spurious reduction of production unary_expr_level -> call_expr_level
## In state 205, spurious reduction of production mult_expr_level -> unary_expr_level
## In state 215, spurious reduction of production add_expr_level -> mult_expr_level
## In state 255, spurious reduction of production cons_expr_level -> add_expr_level
## In state 245, spurious reduction of production cat_expr_level -> cons_expr_level
## In state 277, spurious reduction of production comp_expr_level -> cat_expr_level
## In state 284, spurious reduction of production conj_expr_level -> comp_expr_level
## In state 291, spurious reduction of production disj_expr_level -> conj_expr_level
## In state 243, spurious reduction of production base_expr(expr) -> disj_expr_level
## In state 297, spurious reduction of production base_cond__open(expr) -> base_expr(expr)
## In state 298, spurious reduction of production expr -> base_cond__open(expr)
##
interactive_expr: If Verbatim Then Match Verbatim Type
##
## Ends in an error in state: 599.
##
## match_expr(base_cond) -> Match expr . With option(VBAR) cases(base_cond) [ With Type Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF Directive COLON Attr ]
## match_expr(base_if_then_else) -> Match expr . With option(VBAR) cases(base_if_then_else) [ Else ]
##
## The known suffix of the stack is as follows:
## Match expr
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 218, spurious reduction of production call_expr_level -> core_expr
## In state 224, spurious reduction of production unary_expr_level -> call_expr_level
## In state 205, spurious reduction of production mult_expr_level -> unary_expr_level
## In state 215, spurious reduction of production add_expr_level -> mult_expr_level
## In state 255, spurious reduction of production cons_expr_level -> add_expr_level
## In state 245, spurious reduction of production cat_expr_level -> cons_expr_level
## In state 277, spurious reduction of production comp_expr_level -> cat_expr_level
## In state 284, spurious reduction of production conj_expr_level -> comp_expr_level
## In state 291, spurious reduction of production disj_expr_level -> conj_expr_level
## In state 243, spurious reduction of production base_expr(expr) -> disj_expr_level
## In state 297, spurious reduction of production base_cond__open(expr) -> base_expr(expr)
## In state 298, spurious reduction of production expr -> base_cond__open(expr)
##

Ill-formed pattern matching.
At this point, if the expression whose value is matched is complete,
then the keyword 'with' is expected, followed by matching cases.

interactive_expr: Begin Match Verbatim With WILD ARROW Verbatim With
##
## Ends in an error in state: 587.
##
## cases(base_cond) -> cases(base_cond) . VBAR case_clause(base_cond) [ VBAR ]
## cases(last_expr) -> cases(base_cond) . VBAR case_clause(last_expr) [ End ]
##
## The known suffix of the stack is as follows:
## cases(base_cond)
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 218, spurious reduction of production call_expr_level -> core_expr
## In state 224, spurious reduction of production unary_expr_level -> call_expr_level
## In state 205, spurious reduction of production mult_expr_level -> unary_expr_level
## In state 215, spurious reduction of production add_expr_level -> mult_expr_level
## In state 255, spurious reduction of production cons_expr_level -> add_expr_level
## In state 245, spurious reduction of production cat_expr_level -> cons_expr_level
## In state 277, spurious reduction of production comp_expr_level -> cat_expr_level
## In state 284, spurious reduction of production conj_expr_level -> comp_expr_level
## In state 291, spurious reduction of production disj_expr_level -> conj_expr_level
## In state 521, spurious reduction of production base_expr(base_cond) -> disj_expr_level
## In state 426, spurious reduction of production base_cond__open(base_cond) -> base_expr(base_cond)
## In state 427, spurious reduction of production base_cond -> base_cond__open(base_cond)
## In state 486, spurious reduction of production case_clause(base_cond) -> pattern ARROW base_cond
## In state 493, spurious reduction of production cases(base_cond) -> case_clause(base_cond)
##
interactive_expr: Begin If Verbatim Then Match Verbatim With WILD ARROW Bytes With
##
## Ends in an error in state: 488.
##
## cases(base_cond) -> cases(base_cond) . VBAR case_clause(base_cond) [ VBAR ]
## cases(base_if_then_else) -> cases(base_cond) . VBAR case_clause(base_if_then_else) [ Else ]
##
## The known suffix of the stack is as follows:
## cases(base_cond)
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 218, spurious reduction of production call_expr_level -> core_expr
## In state 224, spurious reduction of production unary_expr_level -> call_expr_level
## In state 205, spurious reduction of production mult_expr_level -> unary_expr_level
## In state 215, spurious reduction of production add_expr_level -> mult_expr_level
## In state 255, spurious reduction of production cons_expr_level -> add_expr_level
## In state 245, spurious reduction of production cat_expr_level -> cons_expr_level
## In state 277, spurious reduction of production comp_expr_level -> cat_expr_level
## In state 284, spurious reduction of production conj_expr_level -> comp_expr_level
## In state 291, spurious reduction of production disj_expr_level -> conj_expr_level
## In state 473, spurious reduction of production base_expr(base_cond) -> disj_expr_level
## In state 426, spurious reduction of production base_cond__open(base_cond) -> base_expr(base_cond)
## In state 427, spurious reduction of production base_cond -> base_cond__open(base_cond)
## In state 486, spurious reduction of production case_clause(base_cond) -> pattern ARROW base_cond
## In state 493, spurious reduction of production cases(base_cond) -> case_clause(base_cond)
##

Ill-formed pattern matching.
At this point, if the case is complete, a vertical bar '|' is
expected, followed by another case starting with a pattern.

interactive_expr: Match Verbatim With WILD CONS Bytes SEMI
##
## Ends in an error in state: 683.
##
## case_clause(base_cond) -> pattern . ARROW base_cond [ With VBAR Type Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF Directive COLON Attr ]
##
## The known suffix of the stack is as follows:
## pattern
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 354, spurious reduction of production cons_pattern_level -> core_pattern
## In state 356, spurious reduction of production cons_pattern_level -> core_pattern CONS cons_pattern_level
## In state 367, spurious reduction of production pattern -> cons_pattern_level
##
interactive_expr: Begin Match Verbatim With WILD RPAR
##
## Ends in an error in state: 375.
##
## case_clause(base_cond) -> pattern . ARROW base_cond [ VBAR ]
## case_clause(last_expr) -> pattern . ARROW last_expr [ End ]
##
## The known suffix of the stack is as follows:
## pattern
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 354, spurious reduction of production cons_pattern_level -> core_pattern
## In state 367, spurious reduction of production pattern -> cons_pattern_level
##
interactive_expr: If Verbatim Then Match Verbatim With WILD RPAR
##
## Ends in an error in state: 384.
##
## case_clause(base_cond) -> pattern . ARROW base_cond [ With VBAR Type Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF Directive COLON Attr ]
## case_clause(base_if_then_else) -> pattern . ARROW base_if_then_else [ Else ]
##
## The known suffix of the stack is as follows:
## pattern
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 354, spurious reduction of production cons_pattern_level -> core_pattern
## In state 367, spurious reduction of production pattern -> cons_pattern_level
##

Ill-formed pattern matching.
At this point, if the pattern is complete, an arrow '->' is expected,
followed by the right-hand side of the case as an expression.

interactive_expr: Begin If Verbatim Then Match Verbatim With With
##
## Ends in an error in state: 382.
##
## match_expr(base_if_then_else) -> Match expr With . option(VBAR) cases(base_if_then_else) [ Else ]
##
## The known suffix of the stack is as follows:
## Match expr With
##
interactive_expr: Begin Match Verbatim With WILD ARROW Bytes VBAR With
##
## Ends in an error in state: 588.
##
## cases(base_cond) -> cases(base_cond) VBAR . case_clause(base_cond) [ VBAR ]
## cases(last_expr) -> cases(base_cond) VBAR . case_clause(last_expr) [ End ]
##
## The known suffix of the stack is as follows:
## cases(base_cond) VBAR
##
interactive_expr: Begin If Verbatim Then Match Verbatim With VBAR Begin
##
## Ends in an error in state: 383.
##
## match_expr(base_if_then_else) -> Match expr With option(VBAR) . cases(base_if_then_else) [ Else ]
##
## The known suffix of the stack is as follows:
## Match expr With option(VBAR)
##
interactive_expr: Begin Match Verbatim With VBAR Begin
##
## Ends in an error in state: 312.
##
## match_expr(last_expr) -> Match expr With option(VBAR) . cases(last_expr) [ End ]
##
## The known suffix of the stack is as follows:
## Match expr With option(VBAR)
##
interactive_expr: Begin Match Verbatim With With
##
## Ends in an error in state: 310.
##
## match_expr(last_expr) -> Match expr With . option(VBAR) cases(last_expr) [ End ]
##
## The known suffix of the stack is as follows:
## Match expr With
##
interactive_expr: If Verbatim Then Match Verbatim With With
##
## Ends in an error in state: 600.
##
## match_expr(base_cond) -> Match expr With . option(VBAR) cases(base_cond) [ With Type Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF Directive COLON Attr ]
## match_expr(base_if_then_else) -> Match expr With . option(VBAR) cases(base_if_then_else) [ Else ]
##
## The known suffix of the stack is as follows:
## Match expr With
##
interactive_expr: If Verbatim Then Match Verbatim With VBAR Begin
##
## Ends in an error in state: 601.
##
## match_expr(base_cond) -> Match expr With option(VBAR) . cases(base_cond) [ With Type Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF Directive COLON Attr ]
## match_expr(base_if_then_else) -> Match expr With option(VBAR) . cases(base_if_then_else) [ Else ]
##
## The known suffix of the stack is as follows:
## Match expr With option(VBAR)
##
interactive_expr: If Verbatim Then Match Verbatim With WILD ARROW Bytes VBAR With
##
## Ends in an error in state: 489.
##
## cases(base_cond) -> cases(base_cond) VBAR . case_clause(base_cond) [ With VBAR Type Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF Directive COLON Attr ]
## cases(base_if_then_else) -> cases(base_cond) VBAR . case_clause(base_if_then_else) [ Else ]
##
## The known suffix of the stack is as follows:
## cases(base_cond) VBAR
##
interactive_expr: Match Verbatim With VBAR Begin
##
## Ends in an error in state: 682.
##
## match_expr(base_cond) -> Match expr With option(VBAR) . cases(base_cond) [ With Type Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF Directive COLON Attr ]
##
## The known suffix of the stack is as follows:
## Match expr With option(VBAR)
##
interactive_expr: Match Verbatim With WILD ARROW Bytes VBAR With
##
## Ends in an error in state: 686.
##
## cases(base_cond) -> cases(base_cond) VBAR . case_clause(base_cond) [ With VBAR Type Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF Directive COLON Attr ]
##
## The known suffix of the stack is as follows:
## cases(base_cond) VBAR
##
interactive_expr: Match Verbatim With With
##
## Ends in an error in state: 681.
##
## match_expr(base_cond) -> Match expr With . option(VBAR) cases(base_cond) [ With Type Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF Directive COLON Attr ]
##
## The known suffix of the stack is as follows:
## Match expr With
##

Ill-formed pattern matching.
At this point, a case is expected to start with a pattern.

interactive_expr: Begin Verbatim With
##
## Ends in an error in state: 533.
##
## last_expr -> seq_expr . [ End ]
## series -> seq_expr . SEMI series [ End ]
##
## The known suffix of the stack is as follows:
## seq_expr
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 218, spurious reduction of production call_expr_level -> core_expr
## In state 224, spurious reduction of production unary_expr_level -> call_expr_level
## In state 205, spurious reduction of production mult_expr_level -> unary_expr_level
## In state 215, spurious reduction of production add_expr_level -> mult_expr_level
## In state 255, spurious reduction of production cons_expr_level -> add_expr_level
## In state 245, spurious reduction of production cat_expr_level -> cons_expr_level
## In state 277, spurious reduction of production comp_expr_level -> cat_expr_level
## In state 284, spurious reduction of production conj_expr_level -> comp_expr_level
## In state 291, spurious reduction of production disj_expr_level -> conj_expr_level
## In state 577, spurious reduction of production seq_expr -> disj_expr_level
##

Ill-formed sequence of expressions.
At this point, if the expression is complete, one of the following is
expected:
  * a semicolon ';' followed by another expression;
  * the keyword 'end' if the sequence is complete.

interactive_expr: C_Some With
##
## Ends in an error in state: 191.
##
## constr_expr -> C_Some . argument [ With VBAR Type Then TIMES SLASH SEMI RPAR RBRACKET RBRACE PLUS Or NE Module Mod MINUS Let LT LE In GT GE End Else EQ EOF Directive CONS COMMA COLON CARET BOOL_OR BOOL_AND Attr ]
##
## The known suffix of the stack is as follows:
## C_Some
##

Ill-formed application to the predefined data constructor 'Some'.
At this point, its argument is expected as an expression.
Hint: To check your understanding of the syntax, try and add
parentheses around what you think is the complete argument.

interactive_expr: Constr DOT With
##
## Ends in an error in state: 179.
##
## module_access_e -> Constr DOT . module_var_e [ With Verbatim VBAR Type True Then TIMES String SLASH SEMI RPAR RBRACKET RBRACE PLUS Or Nat NE Mutez Module Mod MINUS Let Lang LT LPAR LE LBRACKET LBRACE Int In Ident GT GE False End Else EQ EOF Directive Constr C_None CONS COMMA COLON CARET Bytes Begin BOOL_OR BOOL_AND Attr ]
##
## The known suffix of the stack is as follows:
## Constr DOT
##

Ill-formed selection of a value from a module.
At this point, the qualified name of a value is expected.

contract: Type Ident EQ Constr DOT With
##
## Ends in an error in state: 17.
##
## module_access_t -> Constr DOT . module_var_t [ VBAR Type TIMES SEMI RPAR RBRACE Module Let In Ident End EQ EOF Directive COMMA Attr ARROW ]
##
## The known suffix of the stack is as follows:
## Constr DOT
##

Ill-formed selection of a type in a module.
At this point, the qualified name of a type is expected.

interactive_expr: Fun WILD RPAR
##
## Ends in an error in state: 441.
##
## nseq(irrefutable) -> irrefutable . seq(irrefutable) [ ARROW ]
##
## The known suffix of the stack is as follows:
## irrefutable
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 110, spurious reduction of production irrefutable -> core_irrefutable
##
interactive_expr: Fun WILD WILD RPAR
##
## Ends in an error in state: 443.
##
## seq(irrefutable) -> irrefutable . seq(irrefutable) [ ARROW ]
##
## The known suffix of the stack is as follows:
## irrefutable
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 110, spurious reduction of production irrefutable -> core_irrefutable
##

Ill-formed function expression.
At this point, if the parameter is complete, one of the following is
expected:
  * another parameter as an irrefutable pattern (for instance, a
    variable);
  * an arrow '->' followed by the function body as an expression, if
    there are no more parameters.

interactive_expr: Constr DOT Ident DOT With
##
## Ends in an error in state: 167.
##
## projection -> Ident DOT . nsepseq(selection,DOT) [ With Verbatim VBAR Type True Then TIMES String SLASH SEMI RPAR RBRACKET RBRACE PLUS Or Nat NE Mutez Module Mod MINUS Let Lang LT LPAR LE LBRACKET LBRACE Int In Ident GT GE False End Else EQ EOF Directive Constr C_None CONS COMMA COLON CARET Bytes Begin BOOL_OR BOOL_AND Attr ]
##
## The known suffix of the stack is as follows:
## Ident DOT
##
interactive_expr: Ident DOT Int DOT With
##
## Ends in an error in state: 171.
##
## nsepseq(selection,DOT) -> selection DOT . nsepseq(selection,DOT) [ With Verbatim VBAR Type True Then TIMES String SLASH SEMI RPAR RBRACKET RBRACE PLUS Or Nat NE Mutez Module Mod MINUS Let Lang LT LPAR LE LBRACKET LBRACE Int In Ident GT GE False End Else EQ EOF Directive Constr C_None CONS COMMA COLON CARET Bytes Begin BOOL_OR BOOL_AND Attr ]
##
## The known suffix of the stack is as follows:
## selection DOT
##

Ill-formed selection in a record or a tuple.
At this point, one of the following is expected:
  * the name of a record field;
  * the index of a component in a tuple, '0' denoting the first
    component.

interactive_expr: Begin Fun With
##
## Ends in an error in state: 564.
##
## fun_expr(last_expr) -> Fun . nseq(irrefutable) ARROW last_expr [ End ]
##
## The known suffix of the stack is as follows:
## Fun
##
interactive_expr: Begin Match Verbatim With WILD ARROW Fun With
##
## Ends in an error in state: 522.
##
## fun_expr(base_cond) -> Fun . nseq(irrefutable) ARROW base_cond [ VBAR ]
## fun_expr(last_expr) -> Fun . nseq(irrefutable) ARROW last_expr [ End ]
##
## The known suffix of the stack is as follows:
## Fun
##
interactive_expr: Fun With
##
## Ends in an error in state: 174.
##
## fun_expr(expr) -> Fun . nseq(irrefutable) ARROW expr [ With Type Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF Directive COLON Attr ]
##
## The known suffix of the stack is as follows:
## Fun
##
interactive_expr: If Verbatim Then Fun With
##
## Ends in an error in state: 606.
##
## fun_expr(closed_if) -> Fun . nseq(irrefutable) ARROW closed_if [ Else ]
## fun_expr(expr) -> Fun . nseq(irrefutable) ARROW expr [ With Type Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF Directive COLON Attr ]
##
## The known suffix of the stack is as follows:
## Fun
##
interactive_expr: Begin If Verbatim Then Fun With
##
## Ends in an error in state: 541.
##
## fun_expr(closed_if) -> Fun . nseq(irrefutable) ARROW closed_if [ Else ]
##
## The known suffix of the stack is as follows:
## Fun
##
interactive_expr: If Verbatim Then Match Verbatim With WILD ARROW Fun With
##
## Ends in an error in state: 452.
##
## fun_expr(base_cond) -> Fun . nseq(irrefutable) ARROW base_cond [ With VBAR Type Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF Directive COLON Attr ]
## fun_expr(base_if_then_else) -> Fun . nseq(irrefutable) ARROW base_if_then_else [ Else ]
##
## The known suffix of the stack is as follows:
## Fun
##
interactive_expr: Match Verbatim With WILD ARROW Fun With
##
## Ends in an error in state: 496.
##
## fun_expr(base_cond) -> Fun . nseq(irrefutable) ARROW base_cond [ With VBAR Type Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF Directive COLON Attr ]
##
## The known suffix of the stack is as follows:
## Fun
##
interactive_expr: Match Verbatim With WILD ARROW If Verbatim Then Fun With
##
## Ends in an error in state: 392.
##
## fun_expr(base_cond) -> Fun . nseq(irrefutable) ARROW base_cond [ With VBAR Type Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF Directive COLON Attr ]
## fun_expr(closed_if) -> Fun . nseq(irrefutable) ARROW closed_if [ Else ]
##
## The known suffix of the stack is as follows:
## Fun
##

Ill-formed function expression.
At this point, the first parameter is expected as an irrefutable
pattern, for example a variable.

interactive_expr: LBRACE Ident DOT Ident Verbatim
##
## Ends in an error in state: 634.
##
## update_record -> LBRACE path . With sep_or_term_list(field_path_assignment,SEMI) RBRACE [ With Verbatim VBAR Type True Then TIMES String SLASH SEMI RPAR RBRACKET RBRACE PLUS Or Nat NE Mutez Module Mod MINUS Let Lang LT LPAR LE LBRACKET LBRACE Int In Ident GT GE False End Else EQ EOF Directive Constr C_None CONS COMMA COLON CARET Bytes Begin BOOL_OR BOOL_AND Attr ]
##
## The known suffix of the stack is as follows:
## LBRACE path
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 170, spurious reduction of production nsepseq(selection,DOT) -> selection
## In state 173, spurious reduction of production projection -> Ident DOT nsepseq(selection,DOT)
## In state 633, spurious reduction of production path -> projection
##

Ill-formed record update.
At this point, if the record is fully qualified, then the keyword
'with' is expected, followed by field updates (assignments) separated
by semicolons ';'.

interactive_expr: LBRACE Ident EQ Bytes SEMI Ident EQ Bytes SEMI With
##
## Ends in an error in state: 659.
##
## nsepseq(field_assignment,SEMI) -> field_assignment SEMI . nsepseq(field_assignment,SEMI) [ RBRACE ]
## seq(__anonymous_0(field_assignment,SEMI)) -> field_assignment SEMI . seq(__anonymous_0(field_assignment,SEMI)) [ RBRACE ]
##
## The known suffix of the stack is as follows:
## field_assignment SEMI
##
interactive_expr: LBRACE Ident EQ Bytes SEMI With
##
## Ends in an error in state: 654.
##
## nsepseq(field_assignment,SEMI) -> field_assignment SEMI . nsepseq(field_assignment,SEMI) [ RBRACE ]
## nseq(__anonymous_0(field_assignment,SEMI)) -> field_assignment SEMI . seq(__anonymous_0(field_assignment,SEMI)) [ RBRACE ]
##
## The known suffix of the stack is as follows:
## field_assignment SEMI
##

Ill-formed record expression.
At this point, one of the following is expected:
  * more field assignments separated by semicolons ';';
  * a closing brace '}' if the record is complete.

interactive_expr: LBRACE Ident EQ Bytes SEMI Ident EQ Bytes With
##
## Ends in an error in state: 658.
##
## nsepseq(field_assignment,SEMI) -> field_assignment . [ RBRACE ]
## nsepseq(field_assignment,SEMI) -> field_assignment . SEMI nsepseq(field_assignment,SEMI) [ RBRACE ]
## seq(__anonymous_0(field_assignment,SEMI)) -> field_assignment . SEMI seq(__anonymous_0(field_assignment,SEMI)) [ RBRACE ]
##
## The known suffix of the stack is as follows:
## field_assignment
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 218, spurious reduction of production call_expr_level -> core_expr
## In state 224, spurious reduction of production unary_expr_level -> call_expr_level
## In state 205, spurious reduction of production mult_expr_level -> unary_expr_level
## In state 215, spurious reduction of production add_expr_level -> mult_expr_level
## In state 255, spurious reduction of production cons_expr_level -> add_expr_level
## In state 245, spurious reduction of production cat_expr_level -> cons_expr_level
## In state 277, spurious reduction of production comp_expr_level -> cat_expr_level
## In state 284, spurious reduction of production conj_expr_level -> comp_expr_level
## In state 291, spurious reduction of production disj_expr_level -> conj_expr_level
## In state 243, spurious reduction of production base_expr(expr) -> disj_expr_level
## In state 297, spurious reduction of production base_cond__open(expr) -> base_expr(expr)
## In state 298, spurious reduction of production expr -> base_cond__open(expr)
## In state 630, spurious reduction of production field_assignment -> Ident EQ expr
##
interactive_expr: LBRACE Ident EQ Bytes With
##
## Ends in an error in state: 653.
##
## nsepseq(field_assignment,SEMI) -> field_assignment . [ RBRACE ]
## nsepseq(field_assignment,SEMI) -> field_assignment . SEMI nsepseq(field_assignment,SEMI) [ RBRACE ]
## nseq(__anonymous_0(field_assignment,SEMI)) -> field_assignment . SEMI seq(__anonymous_0(field_assignment,SEMI)) [ RBRACE ]
##
## The known suffix of the stack is as follows:
## field_assignment
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 218, spurious reduction of production call_expr_level -> core_expr
## In state 224, spurious reduction of production unary_expr_level -> call_expr_level
## In state 205, spurious reduction of production mult_expr_level -> unary_expr_level
## In state 215, spurious reduction of production add_expr_level -> mult_expr_level
## In state 255, spurious reduction of production cons_expr_level -> add_expr_level
## In state 245, spurious reduction of production cat_expr_level -> cons_expr_level
## In state 277, spurious reduction of production comp_expr_level -> cat_expr_level
## In state 284, spurious reduction of production conj_expr_level -> comp_expr_level
## In state 291, spurious reduction of production disj_expr_level -> conj_expr_level
## In state 243, spurious reduction of production base_expr(expr) -> disj_expr_level
## In state 297, spurious reduction of production base_cond__open(expr) -> base_expr(expr)
## In state 298, spurious reduction of production expr -> base_cond__open(expr)
## In state 630, spurious reduction of production field_assignment -> Ident EQ expr
##

Ill-formed record expression.
At this point, if the expression assigned to the field is complete,
one of the following is expected:
  * a semicolon ';' followed by another field assignment;
  * a closing brace '}' if the record is complete.

interactive_expr: LBRACE Ident With Ident EQ Bytes SEMI Ident EQ Bytes With
##
## Ends in an error in state: 648.
##
## nsepseq(field_path_assignment,SEMI) -> field_path_assignment . [ RBRACE ]
## nsepseq(field_path_assignment,SEMI) -> field_path_assignment . SEMI nsepseq(field_path_assignment,SEMI) [ RBRACE ]
## seq(__anonymous_0(field_path_assignment,SEMI)) -> field_path_assignment . SEMI seq(__anonymous_0(field_path_assignment,SEMI)) [ RBRACE ]
##
## The known suffix of the stack is as follows:
## field_path_assignment
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 218, spurious reduction of production call_expr_level -> core_expr
## In state 224, spurious reduction of production unary_expr_level -> call_expr_level
## In state 205, spurious reduction of production mult_expr_level -> unary_expr_level
## In state 215, spurious reduction of production add_expr_level -> mult_expr_level
## In state 255, spurious reduction of production cons_expr_level -> add_expr_level
## In state 245, spurious reduction of production cat_expr_level -> cons_expr_level
## In state 277, spurious reduction of production comp_expr_level -> cat_expr_level
## In state 284, spurious reduction of production conj_expr_level -> comp_expr_level
## In state 291, spurious reduction of production disj_expr_level -> conj_expr_level
## In state 243, spurious reduction of production base_expr(expr) -> disj_expr_level
## In state 297, spurious reduction of production base_cond__open(expr) -> base_expr(expr)
## In state 298, spurious reduction of production expr -> base_cond__open(expr)
## In state 641, spurious reduction of production field_path_assignment -> path EQ expr
##
interactive_expr: LBRACE Ident With Ident EQ Bytes With
##
## Ends in an error in state: 644.
##
## nsepseq(field_path_assignment,SEMI) -> field_path_assignment . [ RBRACE ]
## nsepseq(field_path_assignment,SEMI) -> field_path_assignment . SEMI nsepseq(field_path_assignment,SEMI) [ RBRACE ]
## nseq(__anonymous_0(field_path_assignment,SEMI)) -> field_path_assignment . SEMI seq(__anonymous_0(field_path_assignment,SEMI)) [ RBRACE ]
##
## The known suffix of the stack is as follows:
## field_path_assignment
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 218, spurious reduction of production call_expr_level -> core_expr
## In state 224, spurious reduction of production unary_expr_level -> call_expr_level
## In state 205, spurious reduction of production mult_expr_level -> unary_expr_level
## In state 215, spurious reduction of production add_expr_level -> mult_expr_level
## In state 255, spurious reduction of production cons_expr_level -> add_expr_level
## In state 245, spurious reduction of production cat_expr_level -> cons_expr_level
## In state 277, spurious reduction of production comp_expr_level -> cat_expr_level
## In state 284, spurious reduction of production conj_expr_level -> comp_expr_level
## In state 291, spurious reduction of production disj_expr_level -> conj_expr_level
## In state 243, spurious reduction of production base_expr(expr) -> disj_expr_level
## In state 297, spurious reduction of production base_cond__open(expr) -> base_expr(expr)
## In state 298, spurious reduction of production expr -> base_cond__open(expr)
## In state 641, spurious reduction of production field_path_assignment -> path EQ expr
##

Ill-formed record update.
At this point, if the expression assigned to the field (update) is
complete, one of the following is expected:
  * a semicolon ';' followed by another field assignment;
  * a closing brace '}' if the update is complete.

interactive_expr: LBRACE Ident EQ Bytes SEMI Ident With
##
## Ends in an error in state: 655.
##
## field_assignment -> Ident . EQ expr [ SEMI RBRACE ]
##
## The known suffix of the stack is as follows:
## Ident
##

Ill-formed assignment to a field in a record.
At this point, the assignment operator '=' is expected, followed by an
expression.

interactive_expr: LBRACE Ident WILD
##
## Ends in an error in state: 162.
##
## field_assignment -> Ident . EQ expr [ SEMI RBRACE ]
## path -> Ident . [ With ]
## projection -> Ident . DOT nsepseq(selection,DOT) [ With ]
##
## The known suffix of the stack is as follows:
## Ident
##

Ill-formed record expression or record update.
At this point, one of the following is expected:
  * the keyword 'with' followed by field updates (assignments);
  * the selection operator '.' if the record to update is not fully
    qualified;
  * the assignment operator '=' followed by an expression, if defining
    a record (as opposed to a record update.)

interactive_expr: LBRACE Ident With Ident DOT Ident With
##
## Ends in an error in state: 639.
##
## field_path_assignment -> path . EQ expr [ SEMI RBRACE ]
##
## The known suffix of the stack is as follows:
## path
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 170, spurious reduction of production nsepseq(selection,DOT) -> selection
## In state 173, spurious reduction of production projection -> Ident DOT nsepseq(selection,DOT)
## In state 633, spurious reduction of production path -> projection
##

Ill-formed record update.
At this point, the assignment operator '=' is expected, followed by an
expression (update).

interactive_expr: LBRACE Ident With Ident EQ Bytes SEMI Ident EQ Bytes SEMI With
##
## Ends in an error in state: 649.
##
## nsepseq(field_path_assignment,SEMI) -> field_path_assignment SEMI . nsepseq(field_path_assignment,SEMI) [ RBRACE ]
## seq(__anonymous_0(field_path_assignment,SEMI)) -> field_path_assignment SEMI . seq(__anonymous_0(field_path_assignment,SEMI)) [ RBRACE ]
##
## The known suffix of the stack is as follows:
## field_path_assignment SEMI
##
interactive_expr: LBRACE Ident With Ident EQ Bytes SEMI With
##
## Ends in an error in state: 645.
##
## nsepseq(field_path_assignment,SEMI) -> field_path_assignment SEMI . nsepseq(field_path_assignment,SEMI) [ RBRACE ]
## nseq(__anonymous_0(field_path_assignment,SEMI)) -> field_path_assignment SEMI . seq(__anonymous_0(field_path_assignment,SEMI)) [ RBRACE ]
##
## The known suffix of the stack is as follows:
## field_path_assignment SEMI
##

Ill-formed record update.
At this point, one of the following is expected:
  * more field assignments (updates) separated by semicolons ';';
  * a closing brace '}' if the update is complete.

interactive_expr: LBRACE Ident With Ident With
##
## Ends in an error in state: 636.
##
## path -> Ident . [ EQ ]
## projection -> Ident . DOT nsepseq(selection,DOT) [ EQ ]
##
## The known suffix of the stack is as follows:
## Ident
##

Ill-formed record update.
At this point, one of the following is expected:
  * the assignment operator '=' if the field to update is fully
    qualified;
  * the selection operator '.' to further qualify the field to update.

interactive_expr: LBRACE Ident With With
##
## Ends in an error in state: 635.
##
## update_record -> LBRACE path With . sep_or_term_list(field_path_assignment,SEMI) RBRACE [ With Verbatim VBAR Type True Then TIMES String SLASH SEMI RPAR RBRACKET RBRACE PLUS Or Nat NE Mutez Module Mod MINUS Let Lang LT LPAR LE LBRACKET LBRACE Int In Ident GT GE False End Else EQ EOF Directive Constr C_None CONS COMMA COLON CARET Bytes Begin BOOL_OR BOOL_AND Attr ]
##
## The known suffix of the stack is as follows:
## LBRACE path With
##

Ill-formed record update.
At this point, assignments to fields (updates) are expected, separated
by semicolons ';' and each starting with fully qualified field names.

interactive_expr: LBRACE With
##
## Ends in an error in state: 161.
##
## record_expr -> LBRACE . sep_or_term_list(field_assignment,SEMI) RBRACE [ With Verbatim VBAR Type True Then TIMES String SLASH SEMI RPAR RBRACKET RBRACE PLUS Or Nat NE Mutez Module Mod MINUS Let Lang LT LPAR LE LBRACKET LBRACE Int In Ident GT GE False End Else EQ EOF Directive Constr C_None CONS COMMA COLON CARET Bytes Begin BOOL_OR BOOL_AND Attr ]
## update_record -> LBRACE . path With sep_or_term_list(field_path_assignment,SEMI) RBRACE [ With Verbatim VBAR Type True Then TIMES String SLASH SEMI RPAR RBRACKET RBRACE PLUS Or Nat NE Mutez Module Mod MINUS Let Lang LT LPAR LE LBRACKET LBRACE Int In Ident GT GE False End Else EQ EOF Directive Constr C_None CONS COMMA COLON CARET Bytes Begin BOOL_OR BOOL_AND Attr ]
##
## The known suffix of the stack is as follows:
## LBRACE
##

Ill-formed record expression or update.
At this point, one of the following is expected:
  * field assignments separated by semicolons ';', if defining a record;
  * the qualified name of the record to update.

interactive_expr: LBRACKET Verbatim SEMI Verbatim With
##
## Ends in an error in state: 670.
##
## nsepseq(expr,SEMI) -> expr . [ RBRACKET ]
## nsepseq(expr,SEMI) -> expr . SEMI nsepseq(expr,SEMI) [ RBRACKET ]
## seq(__anonymous_0(expr,SEMI)) -> expr . SEMI seq(__anonymous_0(expr,SEMI)) [ RBRACKET ]
##
## The known suffix of the stack is as follows:
## expr
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 218, spurious reduction of production call_expr_level -> core_expr
## In state 224, spurious reduction of production unary_expr_level -> call_expr_level
## In state 205, spurious reduction of production mult_expr_level -> unary_expr_level
## In state 215, spurious reduction of production add_expr_level -> mult_expr_level
## In state 255, spurious reduction of production cons_expr_level -> add_expr_level
## In state 245, spurious reduction of production cat_expr_level -> cons_expr_level
## In state 277, spurious reduction of production comp_expr_level -> cat_expr_level
## In state 284, spurious reduction of production conj_expr_level -> comp_expr_level
## In state 291, spurious reduction of production disj_expr_level -> conj_expr_level
## In state 243, spurious reduction of production base_expr(expr) -> disj_expr_level
## In state 297, spurious reduction of production base_cond__open(expr) -> base_expr(expr)
## In state 298, spurious reduction of production expr -> base_cond__open(expr)
##
interactive_expr: LBRACKET Verbatim With
##
## Ends in an error in state: 666.
##
## nsepseq(expr,SEMI) -> expr . [ RBRACKET ]
## nsepseq(expr,SEMI) -> expr . SEMI nsepseq(expr,SEMI) [ RBRACKET ]
## nseq(__anonymous_0(expr,SEMI)) -> expr . SEMI seq(__anonymous_0(expr,SEMI)) [ RBRACKET ]
##
## The known suffix of the stack is as follows:
## expr
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 218, spurious reduction of production call_expr_level -> core_expr
## In state 224, spurious reduction of production unary_expr_level -> call_expr_level
## In state 205, spurious reduction of production mult_expr_level -> unary_expr_level
## In state 215, spurious reduction of production add_expr_level -> mult_expr_level
## In state 255, spurious reduction of production cons_expr_level -> add_expr_level
## In state 245, spurious reduction of production cat_expr_level -> cons_expr_level
## In state 277, spurious reduction of production comp_expr_level -> cat_expr_level
## In state 284, spurious reduction of production conj_expr_level -> comp_expr_level
## In state 291, spurious reduction of production disj_expr_level -> conj_expr_level
## In state 243, spurious reduction of production base_expr(expr) -> disj_expr_level
## In state 297, spurious reduction of production base_cond__open(expr) -> base_expr(expr)
## In state 298, spurious reduction of production expr -> base_cond__open(expr)
##

Ill-formed list of expressions.
At this point, if the list element is complete, one of the
following is expected:
  * a semicolon ';' followed by more elements as expressions;
  * a closing bracket ']' if the list is complete.

interactive_expr: LPAR Verbatim COLON Ident VBAR
##
## Ends in an error in state: 677.
##
## par(annot_expr) -> LPAR annot_expr . RPAR [ With Verbatim VBAR Type True Then TIMES String SLASH SEMI RPAR RBRACKET RBRACE PLUS Or Nat NE Mutez Module Mod MINUS Let Lang LT LPAR LE LBRACKET LBRACE Int In Ident GT GE False End Else EQ EOF Directive Constr C_None CONS COMMA COLON CARET Bytes Begin BOOL_OR BOOL_AND Attr ]
##
## The known suffix of the stack is as follows:
## LPAR annot_expr
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 29, spurious reduction of production cartesian -> core_type
## In state 35, spurious reduction of production fun_type -> cartesian
## In state 71, spurious reduction of production type_expr -> fun_type
## In state 676, spurious reduction of production annot_expr -> expr COLON type_expr
##

Ill-formed annotated expression.
At this point, if the type annotating the expression is complete, then
a closing parenthesis ')' is expected.

contract: Type Ident EQ With
##
## Ends in an error in state: 61.
##
## record_type -> seq(Attr) . LBRACE sep_or_term_list(field_decl,SEMI) RBRACE [ Type SEMI RPAR RBRACE Module Let In End EQ EOF Directive COMMA Attr ]
## sum_type -> seq(Attr) . VBAR nsepseq(variant,VBAR) [ Type SEMI RPAR RBRACE Module Let In End EQ EOF Directive COMMA Attr ]
##
## The known suffix of the stack is as follows:
## seq(Attr)
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 8, spurious reduction of production seq(Attr) ->
##

Ill-formed record type or sum type.
At this point, if the attributes (if any) are complete, one of the
following is expected:
  * an opening brace '{', followed by field declarations,if defining a
    record;
  * a vertical bar '|', followed by variant declarations, if defining
    a sum type.

interactive_expr: LPAR Verbatim With
##
## Ends in an error in state: 673.
##
## annot_expr -> expr . COLON type_expr [ RPAR ]
## par(expr) -> LPAR expr . RPAR [ With Verbatim VBAR Type True Then TIMES String SLASH SEMI RPAR RBRACKET RBRACE PLUS Or Nat NE Mutez Module Mod MINUS Let Lang LT LPAR LE LBRACKET LBRACE Int In Ident GT GE False End Else EQ EOF Directive Constr C_None CONS COMMA COLON CARET Bytes Begin BOOL_OR BOOL_AND Attr ]
##
## The known suffix of the stack is as follows:
## LPAR expr
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 218, spurious reduction of production call_expr_level -> core_expr
## In state 224, spurious reduction of production unary_expr_level -> call_expr_level
## In state 205, spurious reduction of production mult_expr_level -> unary_expr_level
## In state 215, spurious reduction of production add_expr_level -> mult_expr_level
## In state 255, spurious reduction of production cons_expr_level -> add_expr_level
## In state 245, spurious reduction of production cat_expr_level -> cons_expr_level
## In state 277, spurious reduction of production comp_expr_level -> cat_expr_level
## In state 284, spurious reduction of production conj_expr_level -> comp_expr_level
## In state 291, spurious reduction of production disj_expr_level -> conj_expr_level
## In state 243, spurious reduction of production base_expr(expr) -> disj_expr_level
## In state 297, spurious reduction of production base_cond__open(expr) -> base_expr(expr)
## In state 298, spurious reduction of production expr -> base_cond__open(expr)
##

Ill formed expression.
At this point, if the expression is complete, one of the following is
expected:
  * a type annotation starting with a colon ':' and followed by a type
    expression;
  * a closing parenthesis ')'.

interactive_expr: Lang Verbatim With
##
## Ends in an error in state: 687.
##
## code_inj -> Lang expr . RBRACKET [ With Verbatim VBAR Type True Then TIMES String SLASH SEMI RPAR RBRACKET RBRACE PLUS Or Nat NE Mutez Module Mod MINUS Let Lang LT LPAR LE LBRACKET LBRACE Int In Ident GT GE False End Else EQ EOF Directive Constr C_None CONS COMMA COLON CARET Bytes Begin BOOL_OR BOOL_AND Attr ]
##
## The known suffix of the stack is as follows:
## Lang expr
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 218, spurious reduction of production call_expr_level -> core_expr
## In state 224, spurious reduction of production unary_expr_level -> call_expr_level
## In state 205, spurious reduction of production mult_expr_level -> unary_expr_level
## In state 215, spurious reduction of production add_expr_level -> mult_expr_level
## In state 255, spurious reduction of production cons_expr_level -> add_expr_level
## In state 245, spurious reduction of production cat_expr_level -> cons_expr_level
## In state 277, spurious reduction of production comp_expr_level -> cat_expr_level
## In state 284, spurious reduction of production conj_expr_level -> comp_expr_level
## In state 291, spurious reduction of production disj_expr_level -> conj_expr_level
## In state 243, spurious reduction of production base_expr(expr) -> disj_expr_level
## In state 297, spurious reduction of production base_cond__open(expr) -> base_expr(expr)
## In state 298, spurious reduction of production expr -> base_cond__open(expr)
##

Ill-formed code injection.
At this point, a closing bracket ']' is expected.

interactive_expr: MINUS With
##
## Ends in an error in state: 158.
##
## unary_expr_level -> MINUS . call_expr_level [ With VBAR Type Then TIMES SLASH SEMI RPAR RBRACKET RBRACE PLUS Or NE Module Mod MINUS Let LT LE In GT GE End Else EQ EOF Directive CONS COMMA COLON CARET BOOL_OR BOOL_AND Attr ]
##
## The known suffix of the stack is as follows:
## MINUS
##

Ill-formed expression.
At this point, an expression is expected.
Hint: To check your understanding of the syntax, try and add
parentheses around what you think is the negated expression.

contract: Let LPAR Constr LPAR WILD COMMA WILD COMMA With
##
## Ends in an error in state: 114.
##
## nsepseq(core_irrefutable,COMMA) -> core_irrefutable COMMA . nsepseq(core_irrefutable,COMMA) [ WILD SEMI RPAR RBRACE LPAR LBRACE Ident EQ Constr COLON ARROW ]
##
## The known suffix of the stack is as follows:
## core_irrefutable COMMA
##
contract: Let WILD COMMA With
##
## Ends in an error in state: 111.
##
## tuple(core_irrefutable) -> core_irrefutable COMMA . nsepseq(core_irrefutable,COMMA) [ WILD SEMI RPAR RBRACE LPAR LBRACE Ident EQ Constr COLON ARROW ]
##
## The known suffix of the stack is as follows:
## core_irrefutable COMMA
##

Ill-formed tuple of patterns.
At this point, more components of the tuple are expected as patterns
separated by commas ','.

interactive_expr: Match Verbatim With WILD CONS With
##
## Ends in an error in state: 355.
##
## cons_pattern_level -> core_pattern CONS . cons_pattern_level [ SEMI RPAR RBRACKET COMMA COLON ARROW ]
##
## The known suffix of the stack is as follows:
## core_pattern CONS
##

Ill-formed list pattern.
At this point, a pattern that matches a list is expected.

interactive_expr: Not With
##
## Ends in an error in state: 153.
##
## unary_expr_level -> Not . call_expr_level [ With VBAR Type Then TIMES SLASH SEMI RPAR RBRACKET RBRACE PLUS Or NE Module Mod MINUS Let LT LE In GT GE End Else EQ EOF Directive CONS COMMA COLON CARET BOOL_OR BOOL_AND Attr ]
##
## The known suffix of the stack is as follows:
## Not
##
interactive_expr: Verbatim BOOL_AND With
##
## Ends in an error in state: 263.
##
## bin_op(conj_expr_level,BOOL_AND,comp_expr_level) -> conj_expr_level BOOL_AND . comp_expr_level [ With VBAR Type Then SEMI RPAR RBRACKET RBRACE Or Module Let In End Else EOF Directive COMMA COLON BOOL_OR BOOL_AND Attr ]
##
## The known suffix of the stack is as follows:
## conj_expr_level BOOL_AND
##
interactive_expr: Verbatim BOOL_OR With
##
## Ends in an error in state: 294.
##
## bin_op(disj_expr_level,BOOL_OR,conj_expr_level) -> disj_expr_level BOOL_OR . conj_expr_level [ With VBAR Type Then SEMI RPAR RBRACKET RBRACE Or Module Let In End Else EOF Directive COMMA COLON BOOL_OR Attr ]
##
## The known suffix of the stack is as follows:
## disj_expr_level BOOL_OR
##
interactive_expr: Verbatim Or With
##
## Ends in an error in state: 244.
##
## bin_op(disj_expr_level,Or,conj_expr_level) -> disj_expr_level Or . conj_expr_level [ With VBAR Type Then SEMI RPAR RBRACKET RBRACE Or Module Let In End Else EOF Directive COMMA COLON BOOL_OR Attr ]
##
## The known suffix of the stack is as follows:
## disj_expr_level Or
##

Ill-formed expression.
At this point, a Boolean expression is expected.

interactive_expr: Verbatim CARET With
##
## Ends in an error in state: 246.
##
## bin_op(cons_expr_level,CARET,cat_expr_level) -> cons_expr_level CARET . cat_expr_level [ With VBAR Type Then SEMI RPAR RBRACKET RBRACE Or NE Module Let LT LE In GT GE End Else EQ EOF Directive COMMA COLON BOOL_OR BOOL_AND Attr ]
##
## The known suffix of the stack is as follows:
## cons_expr_level CARET
##

Ill-formed string expression.
At this point, an expression denoting a string is expected.

interactive_expr: Verbatim COMMA Verbatim COMMA With
##
## Ends in an error in state: 289.
##
## nsepseq(disj_expr_level,COMMA) -> disj_expr_level COMMA . nsepseq(disj_expr_level,COMMA) [ With VBAR Type Then SEMI RPAR RBRACKET RBRACE Module Let In End Else EOF Directive COLON Attr ]
##
## The known suffix of the stack is as follows:
## disj_expr_level COMMA
##
interactive_expr: Verbatim COMMA With
##
## Ends in an error in state: 286.
##
## tuple(disj_expr_level) -> disj_expr_level COMMA . nsepseq(disj_expr_level,COMMA) [ With VBAR Type Then SEMI RPAR RBRACKET RBRACE Module Let In End Else EOF Directive COLON Attr ]
##
## The known suffix of the stack is as follows:
## disj_expr_level COMMA
##

Ill-formed tuple of expressions.
At this point, another component is expected as an expression.
Hint: To check your understanding of the syntax, try and add
parentheses around what you think is the expression.

interactive_expr: Verbatim CONS With
##
## Ends in an error in state: 260.
##
## bin_op(add_expr_level,CONS,cons_expr_level) -> add_expr_level CONS . cons_expr_level [ With VBAR Type Then SEMI RPAR RBRACKET RBRACE Or NE Module Let LT LE In GT GE End Else EQ EOF Directive COMMA COLON CARET BOOL_OR BOOL_AND Attr ]
##
## The known suffix of the stack is as follows:
## add_expr_level CONS
##

Ill-formed list expression.
At this point, an expression of type list is expected.

interactive_expr: Constr DOT Constr With
##
## Ends in an error in state: 182.
##
## module_access_e -> Constr . DOT module_var_e [ With Verbatim VBAR Type True Then TIMES String SLASH SEMI RPAR RBRACKET RBRACE PLUS Or Nat NE Mutez Module Mod MINUS Let Lang LT LPAR LE LBRACKET LBRACE Int In Ident GT GE False End Else EQ EOF Directive Constr C_None CONS COMMA COLON CARET Bytes Begin BOOL_OR BOOL_AND Attr ]
##
## The known suffix of the stack is as follows:
## Constr
##

Ill-formed selection of a value from a module.
At this point, the selection operator '.' is expected, followed by the
qualified name of a value.

interactive_expr: Verbatim EQ With
##
## Ends in an error in state: 275.
##
## bin_op(comp_expr_level,EQ,cat_expr_level) -> comp_expr_level EQ . cat_expr_level [ With VBAR Type Then SEMI RPAR RBRACKET RBRACE Or NE Module Let LT LE In GT GE End Else EQ EOF Directive COMMA COLON BOOL_OR BOOL_AND Attr ]
##
## The known suffix of the stack is as follows:
## comp_expr_level EQ
##
interactive_expr: Verbatim GE With
##
## Ends in an error in state: 273.
##
## bin_op(comp_expr_level,GE,cat_expr_level) -> comp_expr_level GE . cat_expr_level [ With VBAR Type Then SEMI RPAR RBRACKET RBRACE Or NE Module Let LT LE In GT GE End Else EQ EOF Directive COMMA COLON BOOL_OR BOOL_AND Attr ]
##
## The known suffix of the stack is as follows:
## comp_expr_level GE
##
interactive_expr: Verbatim GT With
##
## Ends in an error in state: 271.
##
## bin_op(comp_expr_level,GT,cat_expr_level) -> comp_expr_level GT . cat_expr_level [ With VBAR Type Then SEMI RPAR RBRACKET RBRACE Or NE Module Let LT LE In GT GE End Else EQ EOF Directive COMMA COLON BOOL_OR BOOL_AND Attr ]
##
## The known suffix of the stack is as follows:
## comp_expr_level GT
##
interactive_expr: Verbatim LE With
##
## Ends in an error in state: 269.
##
## bin_op(comp_expr_level,LE,cat_expr_level) -> comp_expr_level LE . cat_expr_level [ With VBAR Type Then SEMI RPAR RBRACKET RBRACE Or NE Module Let LT LE In GT GE End Else EQ EOF Directive COMMA COLON BOOL_OR BOOL_AND Attr ]
##
## The known suffix of the stack is as follows:
## comp_expr_level LE
##
interactive_expr: Verbatim LT With
##
## Ends in an error in state: 267.
##
## bin_op(comp_expr_level,LT,cat_expr_level) -> comp_expr_level LT . cat_expr_level [ With VBAR Type Then SEMI RPAR RBRACKET RBRACE Or NE Module Let LT LE In GT GE End Else EQ EOF Directive COMMA COLON BOOL_OR BOOL_AND Attr ]
##
## The known suffix of the stack is as follows:
## comp_expr_level LT
##
interactive_expr: Verbatim NE With
##
## Ends in an error in state: 265.
##
## bin_op(comp_expr_level,NE,cat_expr_level) -> comp_expr_level NE . cat_expr_level [ With VBAR Type Then SEMI RPAR RBRACKET RBRACE Or NE Module Let LT LE In GT GE End Else EQ EOF Directive COMMA COLON BOOL_OR BOOL_AND Attr ]
##
## The known suffix of the stack is as follows:
## comp_expr_level NE
##

Ill-formed Boolean expression.
At this point, an expression is expected as the righ-hand side of the
comparison.
Hint: To check your understanding of the syntax, try and add
parentheses around what you think is the expression.

interactive_expr: Verbatim MINUS With
##
## Ends in an error in state: 258.
##
## bin_op(add_expr_level,MINUS,mult_expr_level) -> add_expr_level MINUS . mult_expr_level [ With VBAR Type Then SEMI RPAR RBRACKET RBRACE PLUS Or NE Module MINUS Let LT LE In GT GE End Else EQ EOF Directive CONS COMMA COLON CARET BOOL_OR BOOL_AND Attr ]
##
## The known suffix of the stack is as follows:
## add_expr_level MINUS
##
interactive_expr: Verbatim Mod With
##
## Ends in an error in state: 228.
##
## bin_op(mult_expr_level,Mod,unary_expr_level) -> mult_expr_level Mod . unary_expr_level [ With VBAR Type Then TIMES SLASH SEMI RPAR RBRACKET RBRACE PLUS Or NE Module Mod MINUS Let LT LE In GT GE End Else EQ EOF Directive CONS COMMA COLON CARET BOOL_OR BOOL_AND Attr ]
##
## The known suffix of the stack is as follows:
## mult_expr_level Mod
##
interactive_expr: Verbatim PLUS With
##
## Ends in an error in state: 256.
##
## bin_op(add_expr_level,PLUS,mult_expr_level) -> add_expr_level PLUS . mult_expr_level [ With VBAR Type Then SEMI RPAR RBRACKET RBRACE PLUS Or NE Module MINUS Let LT LE In GT GE End Else EQ EOF Directive CONS COMMA COLON CARET BOOL_OR BOOL_AND Attr ]
##
## The known suffix of the stack is as follows:
## add_expr_level PLUS
##
interactive_expr: Verbatim SLASH With
##
## Ends in an error in state: 226.
##
## bin_op(mult_expr_level,SLASH,unary_expr_level) -> mult_expr_level SLASH . unary_expr_level [ With VBAR Type Then TIMES SLASH SEMI RPAR RBRACKET RBRACE PLUS Or NE Module Mod MINUS Let LT LE In GT GE End Else EQ EOF Directive CONS COMMA COLON CARET BOOL_OR BOOL_AND Attr ]
##
## The known suffix of the stack is as follows:
## mult_expr_level SLASH
##
interactive_expr: Verbatim TIMES With
##
## Ends in an error in state: 216.
##
## bin_op(mult_expr_level,TIMES,unary_expr_level) -> mult_expr_level TIMES . unary_expr_level [ With VBAR Type Then TIMES SLASH SEMI RPAR RBRACKET RBRACE PLUS Or NE Module Mod MINUS Let LT LE In GT GE End Else EQ EOF Directive CONS COMMA COLON CARET BOOL_OR BOOL_AND Attr ]
##
## The known suffix of the stack is as follows:
## mult_expr_level TIMES
##

Ill-formed arithmetic expression.
At this point, an expression is expected.
Hint: To check your understanding of the syntax, try and add
parentheses around what you think is the expression.

interactive_expr: Ident WILD
##
## Ends in an error in state: 720.
##
## interactive_expr -> expr . EOF [ # ]
##
## The known suffix of the stack is as follows:
## expr
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 166, spurious reduction of production core_expr -> Ident
## In state 218, spurious reduction of production call_expr_level -> core_expr
## In state 224, spurious reduction of production unary_expr_level -> call_expr_level
## In state 205, spurious reduction of production mult_expr_level -> unary_expr_level
## In state 215, spurious reduction of production add_expr_level -> mult_expr_level
## In state 255, spurious reduction of production cons_expr_level -> add_expr_level
## In state 245, spurious reduction of production cat_expr_level -> cons_expr_level
## In state 277, spurious reduction of production comp_expr_level -> cat_expr_level
## In state 284, spurious reduction of production conj_expr_level -> comp_expr_level
## In state 291, spurious reduction of production disj_expr_level -> conj_expr_level
## In state 243, spurious reduction of production base_expr(expr) -> disj_expr_level
## In state 297, spurious reduction of production base_cond__open(expr) -> base_expr(expr)
## In state 298, spurious reduction of production expr -> base_cond__open(expr)
##

Ill-formed expression.
At this point, if the expression is complete, the end of file is
expected.

contract: Let Ident WILD COLON String VBAR
##
## Ends in an error in state: 696.
##
## let_binding -> Ident nseq(core_irrefutable) option(type_annotation) . EQ expr [ Type Module Let In End EOF Directive Attr ]
##
## The known suffix of the stack is as follows:
## Ident nseq(core_irrefutable) option(type_annotation)
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 29, spurious reduction of production cartesian -> core_type
## In state 35, spurious reduction of production fun_type -> cartesian
## In state 71, spurious reduction of production type_expr -> fun_type
## In state 131, spurious reduction of production type_annotation -> COLON type_expr
## In state 147, spurious reduction of production option(type_annotation) -> type_annotation
##
contract: Let Ident LPAR Type Ident RPAR WILD COLON Constr With
##
## Ends in an error in state: 148.
##
## let_binding -> Ident par(type_binders) nseq(core_irrefutable) option(type_annotation) . EQ expr [ Type Module Let In End EOF Directive Attr ]
##
## The known suffix of the stack is as follows:
## Ident par(type_binders) nseq(core_irrefutable) option(type_annotation)
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 14, spurious reduction of production variant -> Constr
## In state 42, spurious reduction of production nsepseq(variant,VBAR) -> variant
## In state 70, spurious reduction of production sum_type -> nsepseq(variant,VBAR)
## In state 60, spurious reduction of production type_expr -> sum_type
## In state 131, spurious reduction of production type_annotation -> COLON type_expr
## In state 147, spurious reduction of production option(type_annotation) -> type_annotation
##

Ill-formed value declaration.
At this point, if the type annotation (if any) is complete, the
assignment operator '=' is expected, followed by an expression.

contract: Let Ident WILD WILD With
##
## Ends in an error in state: 693.
##
## seq(core_irrefutable) -> core_irrefutable . seq(core_irrefutable) [ EQ COLON ]
##
## The known suffix of the stack is as follows:
## core_irrefutable
##
contract: Let Ident WILD With
##
## Ends in an error in state: 691.
##
## nseq(core_irrefutable) -> core_irrefutable . seq(core_irrefutable) [ EQ COLON ]
##
## The known suffix of the stack is as follows:
## core_irrefutable
##

Ill-formed function declaration.
At this point, one of the following is expected:
  * another parameter as a pattern, for instance an identifier;
  * the assignment operator '=' followed by the function body as an
    expression;
  * a colon ':' followed by the type of the returned value.

contract: Let LBRACE Ident EQ With
##
## Ends in an error in state: 102.
##
## field_pattern(irrefutable) -> Ident EQ . irrefutable [ SEMI RBRACE ]
##
## The known suffix of the stack is as follows:
## Ident EQ
##
interactive_expr: Match Verbatim With LBRACE Ident EQ With
##
## Ends in an error in state: 322.
##
## field_pattern(core_pattern) -> Ident EQ . core_pattern [ SEMI RBRACE ]
##
## The known suffix of the stack is as follows:
## Ident EQ
##

Ill-formed record pattern.
At this point, the right-hand side of a field pattern is expected.

contract: Let LBRACE Ident With
##
## Ends in an error in state: 101.
##
## field_pattern(irrefutable) -> Ident . [ SEMI RBRACE ]
## field_pattern(irrefutable) -> Ident . EQ irrefutable [ SEMI RBRACE ]
##
## The known suffix of the stack is as follows:
## Ident
##
interactive_expr: Match Verbatim With LBRACE Ident With
##
## Ends in an error in state: 321.
##
## field_pattern(core_pattern) -> Ident . [ SEMI RBRACE ]
## field_pattern(core_pattern) -> Ident . EQ core_pattern [ SEMI RBRACE ]
##
## The known suffix of the stack is as follows:
## Ident
##

Ill-formed record pattern.
At this point, one of the following is expected:
  * the assignment operator '=' followed by the right-hand side as a
    pattern;
  * a semicolon ';' if the field is punned;
  * a closing brace '}' if the record pattern is complete.

contract: Let LBRACE With
##
## Ends in an error in state: 100.
##
## record_pattern(irrefutable) -> LBRACE . sep_or_term_list(field_pattern(irrefutable),SEMI) RBRACE [ WILD SEMI RPAR RBRACE LPAR LBRACE Ident EQ Constr COMMA COLON ARROW ]
##
## The known suffix of the stack is as follows:
## LBRACE
##
interactive_expr: Match Verbatim With LBRACE With
##
## Ends in an error in state: 320.
##
## record_pattern(core_pattern) -> LBRACE . sep_or_term_list(field_pattern(core_pattern),SEMI) RBRACE [ SEMI RPAR RBRACKET RBRACE CONS COMMA COLON ARROW ]
##
## The known suffix of the stack is as follows:
## LBRACE
##

Ill-formed record pattern.
At this point, patterns that match fields are expected, separated by
semicolons ';'.

contract: Let LPAR Constr Constr With
##
## Ends in an error in state: 133.
##
## par(closed_irrefutable) -> LPAR closed_irrefutable . RPAR [ WILD SEMI RPAR RBRACE LPAR LBRACE Ident EQ Constr COMMA COLON ARROW ]
##
## The known suffix of the stack is as follows:
## LPAR closed_irrefutable
##

Ill-formed parenthesised pattern.
At this point, if the pattern is complete, a closing parenthesis ')'
is expected.

contract: Let LPAR Constr LPAR With
##
## Ends in an error in state: 98.
##
## par(closed_irrefutable) -> LPAR . closed_irrefutable RPAR [ WILD SEMI RPAR RBRACE LPAR LBRACE Ident EQ Constr COMMA COLON ARROW ]
## unit -> LPAR . RPAR [ WILD SEMI RPAR RBRACE LPAR LBRACE Ident EQ Constr COMMA COLON ARROW ]
##
## The known suffix of the stack is as follows:
## LPAR
##
interactive_expr: Match Verbatim With LPAR With
##
## Ends in an error in state: 318.
##
## par(closed_pattern) -> LPAR . closed_pattern RPAR [ SEMI RPAR RBRACKET RBRACE CONS COMMA COLON ARROW ]
## unit -> LPAR . RPAR [ SEMI RPAR RBRACKET RBRACE CONS COMMA COLON ARROW ]
##
## The known suffix of the stack is as follows:
## LPAR
##

Ill-formed pattern.
At this point, one of the following is expected:
  * a closing parenthesis ')' if matching the unit value '()';
  * a pattern.

contract: Let LPAR WILD WILD
##
## Ends in an error in state: 129.
##
## closed_irrefutable -> irrefutable . type_annotation [ RPAR ]
## closed_irrefutable -> irrefutable . [ RPAR ]
##
## The known suffix of the stack is as follows:
## irrefutable
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 110, spurious reduction of production irrefutable -> core_irrefutable
##

Ill-formed parenthesised pattern.
At this point, if the enclosed pattern is complete, one of the
following is expected:
  * a type annotation, followed by a closing parenthesis ')';
  * a closing parenthesis ')'.

contract: Let WILD COLON Ident VBAR
##
## Ends in an error in state: 302.
##
## let_binding -> irrefutable option(type_annotation) . EQ expr [ Type Module Let In End EOF Directive Attr ]
##
## The known suffix of the stack is as follows:
## irrefutable option(type_annotation)
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 29, spurious reduction of production cartesian -> core_type
## In state 35, spurious reduction of production fun_type -> cartesian
## In state 71, spurious reduction of production type_expr -> fun_type
## In state 131, spurious reduction of production type_annotation -> COLON type_expr
## In state 147, spurious reduction of production option(type_annotation) -> type_annotation
##

Ill-formed value declaration.
At this point, if the type annotation (if any) is complete, the
assignment operator '=' is expected, followed by an expression.

contract: Let WILD With
##
## Ends in an error in state: 301.
##
## let_binding -> irrefutable . option(type_annotation) EQ expr [ Type Module Let In End EOF Directive Attr ]
##
## The known suffix of the stack is as follows:
## irrefutable
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 110, spurious reduction of production irrefutable -> core_irrefutable
##

Ill-formed value declaration.
At this point, if the pattern is complete, one of the following is
expected:
  * a type annotation for the value being defined;
  * the assignment operator '=' followed by an expression.

contract: Type Ident EQ LBRACE Ident COLON Constr SEMI Ident COLON Ident VBAR
##
## Ends in an error in state: 80.
##
## nsepseq(field_decl,SEMI) -> field_decl . [ RBRACE ]
## nsepseq(field_decl,SEMI) -> field_decl . SEMI nsepseq(field_decl,SEMI) [ RBRACE ]
## seq(__anonymous_0(field_decl,SEMI)) -> field_decl . SEMI seq(__anonymous_0(field_decl,SEMI)) [ RBRACE ]
##
## The known suffix of the stack is as follows:
## field_decl
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 29, spurious reduction of production cartesian -> core_type
## In state 35, spurious reduction of production fun_type -> cartesian
## In state 71, spurious reduction of production type_expr -> fun_type
## In state 68, spurious reduction of production field_decl -> seq(Attr) Ident COLON type_expr
##
contract: Type Ident EQ LBRACE Ident COLON Ident VBAR
##
## Ends in an error in state: 76.
##
## nsepseq(field_decl,SEMI) -> field_decl . [ RBRACE ]
## nsepseq(field_decl,SEMI) -> field_decl . SEMI nsepseq(field_decl,SEMI) [ RBRACE ]
## nseq(__anonymous_0(field_decl,SEMI)) -> field_decl . SEMI seq(__anonymous_0(field_decl,SEMI)) [ RBRACE ]
##
## The known suffix of the stack is as follows:
## field_decl
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 29, spurious reduction of production cartesian -> core_type
## In state 35, spurious reduction of production fun_type -> cartesian
## In state 71, spurious reduction of production type_expr -> fun_type
## In state 68, spurious reduction of production field_decl -> seq(Attr) Ident COLON type_expr
##

Ill-formed record type.
At this point, if the type of the field is complete, one of the
following is expected:
  * a semicolon ';' followed by another field declaration;
  * a closing brace '}' if the record type is complete.

contract: Type Ident EQ LBRACE With
##
## Ends in an error in state: 65.
##
## field_decl -> seq(Attr) . Ident COLON type_expr [ SEMI RBRACE ]
##
## The known suffix of the stack is as follows:
## seq(Attr)
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 64, spurious reduction of production seq(Attr) ->
##

Ill-formed record type.
At this point, if the attributes (if any) are complete, the name of a
field is expected.

contract: Type Ident EQ LBRACE Ident With
##
## Ends in an error in state: 66.
##
## field_decl -> seq(Attr) Ident . COLON type_expr [ SEMI RBRACE ]
##
## The known suffix of the stack is as follows:
## seq(Attr) Ident
##

Ill-formed record type.
At this point, a colon ':' is expected, followed by the type of the
field.

contract: Type Ident EQ LPAR String COMMA Constr RPAR With
##
## Ends in an error in state: 25.
##
## core_type -> par(tuple(type_arg)) . Ident [ VBAR Type TIMES SEMI RPAR RBRACE Module Let In Ident End EQ EOF Directive COMMA Attr ARROW ]
##
## The known suffix of the stack is as follows:
## par(tuple(type_arg))
##

Ill-formed type expression.
At this point, a type constructor with two or more parameters is
expected, like 'map'.

contract: Type Ident EQ LPAR String COMMA String VBAR
##
## Ends in an error in state: 58.
##
## nsepseq(type_arg,COMMA) -> type_arg . [ RPAR ]
## nsepseq(type_arg,COMMA) -> type_arg . COMMA nsepseq(type_arg,COMMA) [ RPAR ]
##
## The known suffix of the stack is as follows:
## type_arg
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 29, spurious reduction of production cartesian -> core_type
## In state 35, spurious reduction of production fun_type -> cartesian
## In state 71, spurious reduction of production type_expr -> fun_type
## In state 57, spurious reduction of production type_arg -> type_expr
##

Ill-formed application to a type constructor.
At this point, if the argument is complete, one of the
following is expected:
  * a closing parenthesis ')';
  * a comma ',' followed by another type expression, if the argument
    is a tuple of types.

contract: Type Ident EQ LPAR String VBAR
##
## Ends in an error in state: 55.
##
## tuple(type_arg) -> type_arg . COMMA nsepseq(type_arg,COMMA) [ RPAR ]
##
## The known suffix of the stack is as follows:
## type_arg
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 29, spurious reduction of production cartesian -> core_type
## In state 35, spurious reduction of production fun_type -> cartesian
## In state 71, spurious reduction of production type_expr -> fun_type
## In state 53, spurious reduction of production type_arg -> type_expr
##

Ill-formed application to a type constructor.
At this point, if the type argument is complete, a comma ',' is
expected, followed by another type expression.

contract: Type Ident EQ String ARROW With
##
## Ends in an error in state: 36.
##
## fun_type -> cartesian ARROW . fun_type [ VBAR Type SEMI RPAR RBRACE Module Let In End EQ EOF Directive COMMA Attr ]
##
## The known suffix of the stack is as follows:
## cartesian ARROW
##

Ill-formed functional type.
At this point, a type other than a sum type or a record is expected.

contract: Type Ident EQ Constr Of With
##
## Ends in an error in state: 15.
##
## variant -> Constr Of . fun_type [ VBAR Type SEMI RPAR RBRACE Module Let In End EQ EOF Directive COMMA Attr ]
##
## The known suffix of the stack is as follows:
## Constr Of
##

Ill-formed variant of a sum type.
At this point, a type other than a sum type or a record is expected.

contract: Type Ident EQ String TIMES Constr With
##
## Ends in an error in state: 16.
##
## module_access_t -> Constr . DOT module_var_t [ VBAR Type TIMES SEMI RPAR RBRACE Module Let In Ident End EQ EOF Directive COMMA Attr ARROW ]
##
## The known suffix of the stack is as follows:
## Constr
##

Ill-formed selection of a type in a module.
At this point, the selection operator '.' is expected, followed by the
qualified name of a type.

contract: Type Ident EQ String TIMES String TIMES With
##
## Ends in an error in state: 33.
##
## nsepseq(core_type,TIMES) -> core_type TIMES . nsepseq(core_type,TIMES) [ VBAR Type SEMI RPAR RBRACE Module Let In End EQ EOF Directive COMMA Attr ARROW ]
##
## The known suffix of the stack is as follows:
## core_type TIMES
##
contract: Type Ident EQ String TIMES With
##
## Ends in an error in state: 30.
##
## cartesian -> core_type TIMES . nsepseq(core_type,TIMES) [ VBAR Type SEMI RPAR RBRACE Module Let In End EQ EOF Directive COMMA Attr ARROW ]
##
## The known suffix of the stack is as follows:
## core_type TIMES
##

Ill-formed product type.
At this point, a type expression is expected, except a sum type, a
record type or a product type.

contract: Type Ident EQ VBAR With
##
## Ends in an error in state: 62.
##
## sum_type -> seq(Attr) VBAR . nsepseq(variant,VBAR) [ Type SEMI RPAR RBRACE Module Let In End EQ EOF Directive COMMA Attr ]
##
## The known suffix of the stack is as follows:
## seq(Attr) VBAR
##
contract: Type Ident EQ Constr VBAR With
##
## Ends in an error in state: 43.
##
## nsepseq(variant,VBAR) -> variant VBAR . nsepseq(variant,VBAR) [ Type SEMI RPAR RBRACE Module Let In End EQ EOF Directive COMMA Attr ]
##
## The known suffix of the stack is as follows:
## variant VBAR
##

Ill-formed variant of sum type.
At this point, a data constructor is expected.

contract: Type Ident With
##
## Ends in an error in state: 7.
##
## type_decl -> Type seq(type_parameter) Ident . EQ type_expr [ Type Module Let In End EOF Directive Attr ]
##
## The known suffix of the stack is as follows:
## Type seq(type_parameter) Ident
##

Ill-formed type declaration.
At this point, the assignment operator '=' is expected, followed by a
type expression.

contract: Type With
##
## Ends in an error in state: 1.
##
## type_decl -> Type . seq(type_parameter) Ident EQ type_expr [ Type Module Let In End EOF Directive Attr ]
##
## The known suffix of the stack is as follows:
## Type
##

Ill-formed type declaration.
At this point, one of the following is expected:
  * the name of the type being defined;
  * a series of type parameters, like 'a 'b 'c etc.

interactive_expr: Type Ident EQ Constr With
##
## Ends in an error in state: 206.
##
## local_type_decl(expr) -> type_decl . In expr [ With Type Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF Directive COLON Attr ]
##
## The known suffix of the stack is as follows:
## type_decl
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 14, spurious reduction of production variant -> Constr
## In state 42, spurious reduction of production nsepseq(variant,VBAR) -> variant
## In state 70, spurious reduction of production sum_type -> nsepseq(variant,VBAR)
## In state 60, spurious reduction of production type_expr -> sum_type
## In state 87, spurious reduction of production type_decl -> Type seq(type_parameter) Ident EQ type_expr
##
interactive_expr: If Verbatim Then Match Verbatim With WILD ARROW Type Ident EQ Constr With
##
## Ends in an error in state: 455.
##
## local_type_decl(base_cond) -> type_decl . In base_cond [ With VBAR Type Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF Directive COLON Attr ]
## local_type_decl(base_if_then_else) -> type_decl . In base_if_then_else [ Else ]
##
## The known suffix of the stack is as follows:
## type_decl
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 14, spurious reduction of production variant -> Constr
## In state 42, spurious reduction of production nsepseq(variant,VBAR) -> variant
## In state 70, spurious reduction of production sum_type -> nsepseq(variant,VBAR)
## In state 60, spurious reduction of production type_expr -> sum_type
## In state 87, spurious reduction of production type_decl -> Type seq(type_parameter) Ident EQ type_expr
##
interactive_expr: Begin If Verbatim Then Type Ident EQ Constr With
##
## Ends in an error in state: 544.
##
## local_type_decl(closed_if) -> type_decl . In closed_if [ Else ]
##
## The known suffix of the stack is as follows:
## type_decl
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 14, spurious reduction of production variant -> Constr
## In state 42, spurious reduction of production nsepseq(variant,VBAR) -> variant
## In state 70, spurious reduction of production sum_type -> nsepseq(variant,VBAR)
## In state 60, spurious reduction of production type_expr -> sum_type
## In state 87, spurious reduction of production type_decl -> Type seq(type_parameter) Ident EQ type_expr
##
interactive_expr: If Verbatim Then Type Ident EQ Constr With
##
## Ends in an error in state: 609.
##
## local_type_decl(closed_if) -> type_decl . In closed_if [ Else ]
## local_type_decl(expr) -> type_decl . In expr [ With Type Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF Directive COLON Attr ]
##
## The known suffix of the stack is as follows:
## type_decl
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 14, spurious reduction of production variant -> Constr
## In state 42, spurious reduction of production nsepseq(variant,VBAR) -> variant
## In state 70, spurious reduction of production sum_type -> nsepseq(variant,VBAR)
## In state 60, spurious reduction of production type_expr -> sum_type
## In state 87, spurious reduction of production type_decl -> Type seq(type_parameter) Ident EQ type_expr
##
interactive_expr: Match Verbatim With WILD ARROW If Verbatim Then Type Ident EQ Constr With
##
## Ends in an error in state: 395.
##
## local_type_decl(base_cond) -> type_decl . In base_cond [ With VBAR Type Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF Directive COLON Attr ]
## local_type_decl(closed_if) -> type_decl . In closed_if [ Else ]
##
## The known suffix of the stack is as follows:
## type_decl
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 14, spurious reduction of production variant -> Constr
## In state 42, spurious reduction of production nsepseq(variant,VBAR) -> variant
## In state 70, spurious reduction of production sum_type -> nsepseq(variant,VBAR)
## In state 60, spurious reduction of production type_expr -> sum_type
## In state 87, spurious reduction of production type_decl -> Type seq(type_parameter) Ident EQ type_expr
##
interactive_expr: Match Verbatim With WILD ARROW Type Ident EQ Constr With
##
## Ends in an error in state: 504.
##
## local_type_decl(base_cond) -> type_decl . In base_cond [ With VBAR Type Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF Directive COLON Attr ]
##
## The known suffix of the stack is as follows:
## type_decl
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 14, spurious reduction of production variant -> Constr
## In state 42, spurious reduction of production nsepseq(variant,VBAR) -> variant
## In state 70, spurious reduction of production sum_type -> nsepseq(variant,VBAR)
## In state 60, spurious reduction of production type_expr -> sum_type
## In state 87, spurious reduction of production type_decl -> Type seq(type_parameter) Ident EQ type_expr
##

Ill-formed local type declaration.
At this point, if the type expression is complete, the keyword 'in' is
expected, followed by an expression.

contract: Type Ident EQ Constr End
##
## Ends in an error in state: 715.
##
## contract -> module_ . EOF [ # ]
##
## The known suffix of the stack is as follows:
## module_
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 14, spurious reduction of production variant -> Constr
## In state 42, spurious reduction of production nsepseq(variant,VBAR) -> variant
## In state 70, spurious reduction of production sum_type -> nsepseq(variant,VBAR)
## In state 60, spurious reduction of production type_expr -> sum_type
## In state 87, spurious reduction of production type_decl -> Type seq(type_parameter) Ident EQ type_expr
## In state 93, spurious reduction of production declaration -> type_decl
## In state 707, spurious reduction of production seq(declaration) ->
## In state 708, spurious reduction of production nseq(declaration) -> declaration seq(declaration)
## In state 701, spurious reduction of production module_ -> nseq(declaration)
##

Ill-formed contract.
At this point, one the following is expected:
  * another top-level declaration;
  * the end of the file.

contract: Module Constr EQ Struct Type Ident EQ Constr EOF
##
## Ends in an error in state: 704.
##
## module_decl -> Module Constr EQ Struct module_ . End [ Type Module Let In End EOF Directive Attr ]
##
## The known suffix of the stack is as follows:
## Module Constr EQ Struct module_
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 14, spurious reduction of production variant -> Constr
## In state 42, spurious reduction of production nsepseq(variant,VBAR) -> variant
## In state 70, spurious reduction of production sum_type -> nsepseq(variant,VBAR)
## In state 60, spurious reduction of production type_expr -> sum_type
## In state 87, spurious reduction of production type_decl -> Type seq(type_parameter) Ident EQ type_expr
## In state 93, spurious reduction of production declaration -> type_decl
## In state 707, spurious reduction of production seq(declaration) ->
## In state 708, spurious reduction of production nseq(declaration) -> declaration seq(declaration)
## In state 701, spurious reduction of production module_ -> nseq(declaration)
##

Ill-formed module declaration.
At this point, if the module declarations are complete, the keyword
'end' is expected.

contract: Module Constr EQ With
##
## Ends in an error in state: 90.
##
## module_alias -> Module Constr EQ . nsepseq(module_name,DOT) [ Type Module Let In End EOF Directive Attr ]
## module_decl -> Module Constr EQ . Struct module_ End [ Type Module Let In End EOF Directive Attr ]
##
## The known suffix of the stack is as follows:
## Module Constr EQ
##

Ill-formed module declaration or module alias declaration.
At this point, one of the following is expected:
  * the qualified name of a module being aliased;
  * the keyword 'struct' followed by declarations, if defining a
    module.

contract: Module Constr With
##
## Ends in an error in state: 89.
##
## module_alias -> Module Constr . EQ nsepseq(module_name,DOT) [ Type Module Let In End EOF Directive Attr ]
## module_decl -> Module Constr . EQ Struct module_ End [ Type Module Let In End EOF Directive Attr ]
##
## The known suffix of the stack is as follows:
## Module Constr
##

Ill-formed module declaration.
At this point, the definitional equality operator '=' is expected to
introduce either the qualified name of a module being aliased, or a
module structure.

contract: Module With
##
## Ends in an error in state: 88.
##
## module_alias -> Module . Constr EQ nsepseq(module_name,DOT) [ Type Module Let In End EOF Directive Attr ]
## module_decl -> Module . Constr EQ Struct module_ End [ Type Module Let In End EOF Directive Attr ]
##
## The known suffix of the stack is as follows:
## Module
##

Ill-formed module declaration.
At this point, the name of the module being declared or aliased is
expected.

interactive_expr: Module Constr EQ Struct Type Ident EQ Constr End With
##
## Ends in an error in state: 230.
##
## local_module_decl(expr) -> module_decl . In expr [ With Type Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF Directive COLON Attr ]
##
## The known suffix of the stack is as follows:
## module_decl
##
interactive_expr: Match Verbatim With WILD ARROW If Verbatim Then Module Constr EQ Struct Type Ident EQ Constr End With
##
## Ends in an error in state: 403.
##
## local_module_decl(base_cond) -> module_decl . In base_cond [ With VBAR Type Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF Directive COLON Attr ]
## local_module_decl(closed_if) -> module_decl . In closed_if [ Else ]
##
## The known suffix of the stack is as follows:
## module_decl
##
interactive_expr: Match Verbatim With WILD ARROW Module Constr EQ Struct Type Ident EQ Constr End With
##
## Ends in an error in state: 512.
##
## local_module_decl(base_cond) -> module_decl . In base_cond [ With VBAR Type Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF Directive COLON Attr ]
##
## The known suffix of the stack is as follows:
## module_decl
##
interactive_expr: If Verbatim Then Match Verbatim With WILD ARROW Module Constr EQ Struct Type Ident EQ Constr End With
##
## Ends in an error in state: 463.
##
## local_module_decl(base_cond) -> module_decl . In base_cond [ With VBAR Type Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF Directive COLON Attr ]
## local_module_decl(base_if_then_else) -> module_decl . In base_if_then_else [ Else ]
##
## The known suffix of the stack is as follows:
## module_decl
##
interactive_expr: If Verbatim Then Module Constr EQ Struct Type Ident EQ Constr End With
##
## Ends in an error in state: 617.
##
## local_module_decl(closed_if) -> module_decl . In closed_if [ Else ]
## local_module_decl(expr) -> module_decl . In expr [ With Type Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF Directive COLON Attr ]
##
## The known suffix of the stack is as follows:
## module_decl
##
interactive_expr: Begin If Verbatim Then Module Constr EQ Struct Type Ident EQ Constr End With
##
## Ends in an error in state: 552.
##
## local_module_decl(closed_if) -> module_decl . In closed_if [ Else ]
##
## The known suffix of the stack is as follows:
## module_decl
##

Ill-formed local module declaration.
At this point, the keyword 'in' is expected, followed by an
expression.

interactive_expr: Module Constr EQ Constr Type
##
## Ends in an error in state: 232.
##
## local_module_alias(expr) -> module_alias . In expr [ With Type Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF Directive COLON Attr ]
##
## The known suffix of the stack is as follows:
## module_alias
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 711, spurious reduction of production nsepseq(module_name,DOT) -> Constr
## In state 714, spurious reduction of production module_alias -> Module Constr EQ nsepseq(module_name,DOT)
##
interactive_expr: Match Verbatim With WILD ARROW If Verbatim Then Module Constr EQ Constr Type
##
## Ends in an error in state: 405.
##
## local_module_alias(base_cond) -> module_alias . In base_cond [ With VBAR Type Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF Directive COLON Attr ]
## local_module_alias(closed_if) -> module_alias . In closed_if [ Else ]
##
## The known suffix of the stack is as follows:
## module_alias
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 711, spurious reduction of production nsepseq(module_name,DOT) -> Constr
## In state 714, spurious reduction of production module_alias -> Module Constr EQ nsepseq(module_name,DOT)
##
interactive_expr: If Verbatim Then Match Verbatim With WILD ARROW Module Constr EQ Constr Type
##
## Ends in an error in state: 465.
##
## local_module_alias(base_cond) -> module_alias . In base_cond [ With VBAR Type Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF Directive COLON Attr ]
## local_module_alias(base_if_then_else) -> module_alias . In base_if_then_else [ Else ]
##
## The known suffix of the stack is as follows:
## module_alias
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 711, spurious reduction of production nsepseq(module_name,DOT) -> Constr
## In state 714, spurious reduction of production module_alias -> Module Constr EQ nsepseq(module_name,DOT)
##
interactive_expr: Match Verbatim With WILD ARROW Module Constr EQ Constr Type
##
## Ends in an error in state: 514.
##
## local_module_alias(base_cond) -> module_alias . In base_cond [ With VBAR Type Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF Directive COLON Attr ]
##
## The known suffix of the stack is as follows:
## module_alias
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 711, spurious reduction of production nsepseq(module_name,DOT) -> Constr
## In state 714, spurious reduction of production module_alias -> Module Constr EQ nsepseq(module_name,DOT)
##
interactive_expr: Begin If Verbatim Then Module Constr EQ Constr Type
##
## Ends in an error in state: 554.
##
## local_module_alias(closed_if) -> module_alias . In closed_if [ Else ]
##
## The known suffix of the stack is as follows:
## module_alias
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 711, spurious reduction of production nsepseq(module_name,DOT) -> Constr
## In state 714, spurious reduction of production module_alias -> Module Constr EQ nsepseq(module_name,DOT)
##
interactive_expr: If Verbatim Then Module Constr EQ Constr Type
##
## Ends in an error in state: 619.
##
## local_module_alias(closed_if) -> module_alias . In closed_if [ Else ]
## local_module_alias(expr) -> module_alias . In expr [ With Type Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF Directive COLON Attr ]
##
## The known suffix of the stack is as follows:
## module_alias
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 711, spurious reduction of production nsepseq(module_name,DOT) -> Constr
## In state 714, spurious reduction of production module_alias -> Module Constr EQ nsepseq(module_name,DOT)
##

Ill-formed local module declaration.
At this point, if the module to be aliased is fully qualified, the
keyword 'in' is expected, follwed by an expression.

contract: Module Constr EQ Constr DOT With
##
## Ends in an error in state: 712.
##
## nsepseq(module_name,DOT) -> Constr DOT . nsepseq(module_name,DOT) [ Type Module Let In End EOF Directive Attr ]
##
## The known suffix of the stack is as follows:
## Constr DOT
##

Ill-formed module qualification.
At this point, a module name is expected.

contract: Type QUOTE With
##
## Ends in an error in state: 2.
##
## type_parameter -> QUOTE . Ident [ RPAR QUOTE Ident COMMA ]
##
## The known suffix of the stack is as follows:
## QUOTE
##

Ill-formed type parameter.
At this point, an identifier is expected.

contract: Type QUOTE Ident With
##
## Ends in an error in state: 4.
##
## seq(type_parameter) -> type_parameter . seq(type_parameter) [ Ident ]
##
## The known suffix of the stack is as follows:
## type_parameter
##

Ill-formed type declaration.
At this point, if the type parameter is complete, one of the following
is expected:
  * another type parameter;
  * the name of the type being defined.

interactive_expr: LPAR Verbatim COLON QUOTE Ident With
##
## Ends in an error in state: 21.
##
## core_type -> unique_type_arg . Ident [ VBAR Type TIMES SEMI RPAR RBRACE Module Let In Ident End EQ EOF Directive COMMA Attr ARROW ]
##
## The known suffix of the stack is as follows:
## unique_type_arg
##

Ill-formed type application.
At this point, if the unique type argument is complete, the name of
the type constructor is expected.

interactive_expr: Match Verbatim With LBRACE Ident SEMI Ident EQ Bytes With
##
## Ends in an error in state: 346.
##
## nsepseq(field_pattern(core_pattern),SEMI) -> field_pattern(core_pattern) . [ RBRACE ]
## nsepseq(field_pattern(core_pattern),SEMI) -> field_pattern(core_pattern) . SEMI nsepseq(field_pattern(core_pattern),SEMI) [ RBRACE ]
## seq(__anonymous_0(field_pattern(core_pattern),SEMI)) -> field_pattern(core_pattern) . SEMI seq(__anonymous_0(field_pattern(core_pattern),SEMI)) [ RBRACE ]
##
## The known suffix of the stack is as follows:
## field_pattern(core_pattern)
##
interactive_expr: Fun LBRACE Ident EQ Constr With
##
## Ends in an error in state: 120.
##
## nsepseq(field_pattern(irrefutable),SEMI) -> field_pattern(irrefutable) . [ RBRACE ]
## nsepseq(field_pattern(irrefutable),SEMI) -> field_pattern(irrefutable) . SEMI nsepseq(field_pattern(irrefutable),SEMI) [ RBRACE ]
## nseq(__anonymous_0(field_pattern(irrefutable),SEMI)) -> field_pattern(irrefutable) . SEMI seq(__anonymous_0(field_pattern(irrefutable),SEMI)) [ RBRACE ]
##
## The known suffix of the stack is as follows:
## field_pattern(irrefutable)
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 110, spurious reduction of production irrefutable -> core_irrefutable
## In state 109, spurious reduction of production field_pattern(irrefutable) -> Ident EQ irrefutable
##
interactive_expr: Fun LBRACE Ident SEMI Ident EQ Constr With
##
## Ends in an error in state: 124.
##
## nsepseq(field_pattern(irrefutable),SEMI) -> field_pattern(irrefutable) . [ RBRACE ]
## nsepseq(field_pattern(irrefutable),SEMI) -> field_pattern(irrefutable) . SEMI nsepseq(field_pattern(irrefutable),SEMI) [ RBRACE ]
## seq(__anonymous_0(field_pattern(irrefutable),SEMI)) -> field_pattern(irrefutable) . SEMI seq(__anonymous_0(field_pattern(irrefutable),SEMI)) [ RBRACE ]
##
## The known suffix of the stack is as follows:
## field_pattern(irrefutable)
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 110, spurious reduction of production irrefutable -> core_irrefutable
## In state 109, spurious reduction of production field_pattern(irrefutable) -> Ident EQ irrefutable
##
interactive_expr: Match Verbatim With LBRACE Ident EQ Bytes With
##
## Ends in an error in state: 342.
##
## nsepseq(field_pattern(core_pattern),SEMI) -> field_pattern(core_pattern) . [ RBRACE ]
## nsepseq(field_pattern(core_pattern),SEMI) -> field_pattern(core_pattern) . SEMI nsepseq(field_pattern(core_pattern),SEMI) [ RBRACE ]
## nseq(__anonymous_0(field_pattern(core_pattern),SEMI)) -> field_pattern(core_pattern) . SEMI seq(__anonymous_0(field_pattern(core_pattern),SEMI)) [ RBRACE ]
##
## The known suffix of the stack is as follows:
## field_pattern(core_pattern)
##

Ill-formed record pattern.
At this point, if the field is complete, one of the following is
expected:
  * a semicolon ';' followed by another record field pattern;
  * a closing brace '}' if the record pattern is complete.

interactive_expr: Fun LBRACE Ident SEMI With
##
## Ends in an error in state: 121.
##
## nsepseq(field_pattern(irrefutable),SEMI) -> field_pattern(irrefutable) SEMI . nsepseq(field_pattern(irrefutable),SEMI) [ RBRACE ]
## nseq(__anonymous_0(field_pattern(irrefutable),SEMI)) -> field_pattern(irrefutable) SEMI . seq(__anonymous_0(field_pattern(irrefutable),SEMI)) [ RBRACE ]
##
## The known suffix of the stack is as follows:
## field_pattern(irrefutable) SEMI
##
interactive_expr: Fun LBRACE Ident SEMI Ident SEMI With
##
## Ends in an error in state: 125.
##
## nsepseq(field_pattern(irrefutable),SEMI) -> field_pattern(irrefutable) SEMI . nsepseq(field_pattern(irrefutable),SEMI) [ RBRACE ]
## seq(__anonymous_0(field_pattern(irrefutable),SEMI)) -> field_pattern(irrefutable) SEMI . seq(__anonymous_0(field_pattern(irrefutable),SEMI)) [ RBRACE ]
##
## The known suffix of the stack is as follows:
## field_pattern(irrefutable) SEMI
##
interactive_expr: Match Verbatim With LBRACE Ident SEMI With
##
## Ends in an error in state: 343.
##
## nsepseq(field_pattern(core_pattern),SEMI) -> field_pattern(core_pattern) SEMI . nsepseq(field_pattern(core_pattern),SEMI) [ RBRACE ]
## nseq(__anonymous_0(field_pattern(core_pattern),SEMI)) -> field_pattern(core_pattern) SEMI . seq(__anonymous_0(field_pattern(core_pattern),SEMI)) [ RBRACE ]
##
## The known suffix of the stack is as follows:
## field_pattern(core_pattern) SEMI
##
interactive_expr: Match Verbatim With LBRACE Ident SEMI Ident SEMI With
##
## Ends in an error in state: 347.
##
## nsepseq(field_pattern(core_pattern),SEMI) -> field_pattern(core_pattern) SEMI . nsepseq(field_pattern(core_pattern),SEMI) [ RBRACE ]
## seq(__anonymous_0(field_pattern(core_pattern),SEMI)) -> field_pattern(core_pattern) SEMI . seq(__anonymous_0(field_pattern(core_pattern),SEMI)) [ RBRACE ]
##
## The known suffix of the stack is as follows:
## field_pattern(core_pattern) SEMI
##

Ill-formed record pattern.
At this point, if the field pattern is complete, one of the following
is expected:
  * another field pattern;
  * a closing brace '}' if the record pattern is complete.

contract: Let Ident LPAR With
##
## Ends in an error in state: 136.
##
## par(closed_irrefutable) -> LPAR . closed_irrefutable RPAR [ WILD LPAR LBRACE Ident EQ Constr COLON ]
## par(type_binders) -> LPAR . type_binders RPAR [ WILD LPAR LBRACE Ident Constr ]
## unit -> LPAR . RPAR [ WILD LPAR LBRACE Ident EQ Constr COLON ]
##
## The known suffix of the stack is as follows:
## LPAR
##

Ill-formed value declaration.
At this point, one of the following is expected:
  * the keyword 'type' followed by type parameters and a closing
    parenthesis ')';
  * a closing parenthesis ')' if making the unit pattern;
  * a parameter as an irrefutable pattern followed by a closing
    parenthesis ')'.

contract: Let Ident LPAR Type With
##
## Ends in an error in state: 137.
##
## type_binders -> Type . nseq(type_var) [ RPAR ]
##
## The known suffix of the stack is as follows:
## Type
##

Ill-formed type parameters.
At this point, a type parameter without a quote is expected.

contract: Let Ident LPAR Type Ident With
##
## Ends in an error in state: 138.
##
## nseq(type_var) -> Ident . seq(type_var) [ RPAR ]
##
## The known suffix of the stack is as follows:
## Ident
##
contract: Let Ident LPAR Type Ident Ident With
##
## Ends in an error in state: 139.
##
## seq(type_var) -> Ident . seq(type_var) [ RPAR ]
##
## The known suffix of the stack is as follows:
## Ident
##

Ill-formed type parameters.
At this point, one of the following is expected:
  * a type parameter without a quote;
  * a closing parenthesis ')' if no more parameters.

contract: Let Ident LPAR Type Ident RPAR With
##
## Ends in an error in state: 145.
##
## let_binding -> Ident par(type_binders) . nseq(core_irrefutable) option(type_annotation) EQ expr [ Type Module Let In End EOF Directive Attr ]
##
## The known suffix of the stack is as follows:
## Ident par(type_binders)
##

Ill-formed value declaration.
At this point, a parameter is expected as an irrefutable pattern.

interactive_expr: Match Verbatim With LBRACKET With
##
## Ends in an error in state: 319.
##
## list__(cons_pattern_level) -> LBRACKET . option(sep_or_term_list(cons_pattern_level,SEMI)) RBRACKET [ SEMI RPAR RBRACKET RBRACE CONS COMMA COLON ARROW ]
##
## The known suffix of the stack is as follows:
## LBRACKET
##
interactive_expr: Match Verbatim With LBRACKET WILD SEMI With
##
## Ends in an error in state: 358.
##
## nsepseq(cons_pattern_level,SEMI) -> cons_pattern_level SEMI . nsepseq(cons_pattern_level,SEMI) [ RBRACKET ]
## nseq(__anonymous_0(cons_pattern_level,SEMI)) -> cons_pattern_level SEMI . seq(__anonymous_0(cons_pattern_level,SEMI)) [ RBRACKET ]
##
## The known suffix of the stack is as follows:
## cons_pattern_level SEMI
##

Ill-formed list pattern.
At this point, one of the following is expected:
  * a list element as a pattern;
  * a closing bracket ']' if the list is empty.

interactive_expr: Match Verbatim With C_Some With
##
## Ends in an error in state: 327.
##
## constr_pattern -> C_Some . core_pattern [ SEMI RPAR RBRACKET RBRACE CONS COMMA COLON ARROW ]
##
## The known suffix of the stack is as follows:
## C_Some
##

Ill-formed application of the constructor 'Some'.
At this point, a pattern matching its argument is expected.

interactive_expr: Match Verbatim With LBRACKET WILD SEMI WILD With
##
## Ends in an error in state: 361.
##
## nsepseq(cons_pattern_level,SEMI) -> cons_pattern_level . [ RBRACKET ]
## nsepseq(cons_pattern_level,SEMI) -> cons_pattern_level . SEMI nsepseq(cons_pattern_level,SEMI) [ RBRACKET ]
## seq(__anonymous_0(cons_pattern_level,SEMI)) -> cons_pattern_level . SEMI seq(__anonymous_0(cons_pattern_level,SEMI)) [ RBRACKET ]
##
## The known suffix of the stack is as follows:
## cons_pattern_level
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 354, spurious reduction of production cons_pattern_level -> core_pattern
##
interactive_expr: Match Verbatim With LBRACKET WILD With
##
## Ends in an error in state: 357.
##
## nsepseq(cons_pattern_level,SEMI) -> cons_pattern_level . [ RBRACKET ]
## nsepseq(cons_pattern_level,SEMI) -> cons_pattern_level . SEMI nsepseq(cons_pattern_level,SEMI) [ RBRACKET ]
## nseq(__anonymous_0(cons_pattern_level,SEMI)) -> cons_pattern_level . SEMI seq(__anonymous_0(cons_pattern_level,SEMI)) [ RBRACKET ]
##
## The known suffix of the stack is as follows:
## cons_pattern_level
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 354, spurious reduction of production cons_pattern_level -> core_pattern
##

Ill-formed list pattern.
At this point, if the pattern matching the element is complete, one of
the following is expected:
  * a semicolon ';' followed by another pattern;
  * a closing bracket '}' if the list is complete.

interactive_expr: Match Verbatim With LBRACKET WILD SEMI WILD SEMI With
##
## Ends in an error in state: 362.
##
## nsepseq(cons_pattern_level,SEMI) -> cons_pattern_level SEMI . nsepseq(cons_pattern_level,SEMI) [ RBRACKET ]
## seq(__anonymous_0(cons_pattern_level,SEMI)) -> cons_pattern_level SEMI . seq(__anonymous_0(cons_pattern_level,SEMI)) [ RBRACKET ]
##
## The known suffix of the stack is as follows:
## cons_pattern_level SEMI
##

Ill-formed list pattern.
At this point, a list element is expected as a pattern.

interactive_expr: Match Verbatim With LPAR WILD With
##
## Ends in an error in state: 365.
##
## closed_pattern -> pattern . type_annotation [ RPAR ]
## closed_pattern -> pattern . [ RPAR ]
##
## The known suffix of the stack is as follows:
## pattern
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 354, spurious reduction of production cons_pattern_level -> core_pattern
## In state 367, spurious reduction of production pattern -> cons_pattern_level
##

Ill-formed parenthesised pattern.
At this point, if the pattern is complete, one of the following is
expected:
  * a closing parenthesis ')';
  * a type annotation starting with a colon ':'.

interactive_expr: Match Verbatim With WILD COMMA With
##
## Ends in an error in state: 368.
##
## tuple(cons_pattern_level) -> cons_pattern_level COMMA . nsepseq(cons_pattern_level,COMMA) [ RPAR COLON ARROW ]
##
## The known suffix of the stack is as follows:
## cons_pattern_level COMMA
##
interactive_expr: Match Verbatim With WILD COMMA WILD COMMA With
##
## Ends in an error in state: 371.
##
## nsepseq(cons_pattern_level,COMMA) -> cons_pattern_level COMMA . nsepseq(cons_pattern_level,COMMA) [ RPAR COLON ARROW ]
##
## The known suffix of the stack is as follows:
## cons_pattern_level COMMA
##

Ill-formed tuple of patterns.
At this point, another component is expected as a pattern.

interactive_expr: Match Verbatim With LPAR WILD COLON Constr With
##
## Ends in an error in state: 373.
##
## par(closed_pattern) -> LPAR closed_pattern . RPAR [ SEMI RPAR RBRACKET RBRACE CONS COMMA COLON ARROW ]
##
## The known suffix of the stack is as follows:
## LPAR closed_pattern
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 14, spurious reduction of production variant -> Constr
## In state 42, spurious reduction of production nsepseq(variant,VBAR) -> variant
## In state 70, spurious reduction of production sum_type -> nsepseq(variant,VBAR)
## In state 60, spurious reduction of production type_expr -> sum_type
## In state 131, spurious reduction of production type_annotation -> COLON type_expr
## In state 366, spurious reduction of production closed_pattern -> pattern type_annotation
##

Ill-formed parenthesised pattern.
At this point, if the pattern is complete, a closing parenthesis ')'
is expected.
