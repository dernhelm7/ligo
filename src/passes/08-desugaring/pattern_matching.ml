(*

This implements the pattern_matching compiler of `Peyton-Jones, S.L., The Implementation of Functional Programming Languages`, chapter 5.
By reduction, this algorithm transforms pattern matching expression into (nested) cases expressions.
`Sugar` match expres0sion being 'pattern matching' expression and `Core`/`Typed` being 'case expressions'.

List patterns are treated as the variant type `NIL | Cons of (hd , tl)` would be
"product patterns" (e.g. tuple & record) are considered variables, but an extra rule (product_rule) was necessary to handle them

*)

module I = Ast_sugar
module O = Ast_core

open Trace
(* open Stage_common.Maps *)

type matchees = O.expression_variable list
type pattern = O.type_expression I.pattern
type equations = (pattern list * O.expression) list

let is_var : _ I.pattern -> bool = fun p ->
  match p with
  | P_var _ -> true
  | P_tuple _ -> true
  | P_record _ -> true
  | P_unit -> true
  | _ -> false
let is_product : _ I.pattern -> bool = fun p ->
  match p with
  | P_tuple _ -> true
  | P_record _ -> true
  | _ -> false

type 'a pm_result = ('a, Errors.desugaring_error) result

let list_sep_x x = let open Simple_utils.PP_helpers in list_sep x (tag "@,")
let pp_matchees : Format.formatter -> O.expression_variable list -> unit =
  fun ppf lst ->
    let lst = List.map (fun (e:O.expression_variable) -> e.wrap_content) lst in
    Format.fprintf ppf "@[%a@]" (Simple_utils.PP_helpers.list_sep_d_par Var.pp) lst

let pp_patterns : Format.formatter -> pattern list -> unit =
  fun ppf lst ->
    Format.fprintf ppf "@[ [ %a ]@]" (Simple_utils.PP_helpers.list_sep_d (Stage_common.PP.match_pattern O.PP.type_expression)) lst

let pp_eq : Format.formatter ->  (pattern list * O.expression) -> unit =
  fun ppf (pl,body) ->
    Format.fprintf ppf "%a -> %a" pp_patterns pl O.PP.expression body

let pp_eqs : Format.formatter ->  equations -> unit =
  fun ppf lst ->
    Format.fprintf ppf "@[<v>[@,%a@,] @]" (list_sep_x pp_eq) lst

(*
  `substitute_var_in_body to_subst new_var body` replaces variables equal to `to_subst` with variable `new_var` in expression `body`.
  note that `new_var` here is never a user variable (always previously generated by the compiler)
*)
let substitute_var_in_body : O.expression_variable -> O.expression_variable -> O.expression -> O.expression pm_result =
  fun to_subst new_var body ->
    let () = Format.printf "substituting %a by %a in %a\n" O.PP.expression_variable to_subst O.PP.expression_variable new_var O.PP.expression body in
    let aux : O.expression -> (O.expression,_) result =
      fun exp ->
        match exp.content with
        | O.E_variable n when Var.equal n.wrap_content to_subst.wrap_content -> ok { exp with content = E_variable new_var } 
        | _ -> ok exp
    in
    Self_ast_core.map_expression aux body

let make_var_pattern : O.expression_variable -> O.type_expression I.pattern =
  fun var -> P_var { var ; ascr = None }

let rec partition : ('a -> bool) -> 'a list -> 'a list list =
  fun f lst ->
    let add_inner x ll =
      match ll with
      | hdl::tll -> (x::hdl)::tll
      | _ -> assert false
    in
    match lst with
    | [] -> []
    | [x] -> [[x]]
    | x::x'::tl ->
      if f x = f x' then add_inner x (partition f (x'::tl))
      else [x] :: (partition f (x'::tl))

let split_equations : equations -> equations O.label_map pm_result =
  fun eqs ->
    let aux : pattern list * O.expression -> equations O.label_map -> equations O.label_map =
      fun (pl,body) m ->
        let phd = List.hd pl in
        let ptl = List.tl pl in
        let dummy_p : unit -> pattern = fun () ->
          let var =  Location.wrap @@ Var.fresh ~name:"_" () in
          make_var_pattern var
        in
        match phd with
        | P_variant (label,p_opt) ->
          let upd : equations option -> equations option = fun kopt ->
            match kopt, p_opt with
            | Some eqs , None   -> Some ( (dummy_p ()::ptl , body)::eqs )
            | Some eqs , Some p -> Some ( (p::ptl          , body)::eqs )
            | None     , None   -> Some [ (dummy_p ()::ptl , body) ]
            | None     , Some p -> Some [ (p::ptl          , body) ]
          in
          O.LMap.update label upd m
        | _ -> failwith "impossible: previously regarded as a 'constructor rule', function rule must have a bug"
    in
    ok @@ List.fold_right aux eqs O.LMap.empty

let rec match_ : matchees -> equations -> O.expression_content -> O.expression_content pm_result = fun ms eqs def ->
  (* REMITODO, Invariant : for all eq in eqs : (List.length rules) = (List.length (fst eq)) *)
  let () = Format.printf "CALLING match_:\n matchees: %a\n eqs: %a\n-----\n" pp_matchees ms pp_eqs eqs in
  match ms , eqs with
  | [] , [([],body)] -> let () = Format.printf "Empty rule applies\n" in ok body.content
  | [] , eqs when List.for_all (fun (ps,_) -> List.length ps = 0) eqs -> failwith "Redundant pattern"
  | _ ->
    let leq = partition (fun (pl,_) -> is_var (List.hd pl)) eqs in
    let () =
      if List.length leq > 1 then
        let () = Format.printf "Mixture rule applies, partitions:\n" in
        List.iter (fun eq -> Format.printf "%a\n-\n" pp_eqs eq) leq
    in
    let aux = fun acc part_eq ->
      let%bind n = consvar ms part_eq acc in
      let () = Format.printf "RETOURNING FROM PART_EQ with : %a\n" O.PP.expression_content n in
      ok n
    in
    bind_fold_right_list aux def leq

and consvar : matchees -> equations -> O.expression_content -> O.expression_content pm_result = fun ms eqs def ->
  let () = Format.printf "CALLING CONSVAR WITH:\n matchees: %a\n eqs: %a\n-----\n" pp_matchees ms pp_eqs eqs in
  let p1s = List.map (fun el -> List.hd @@ fst el) eqs in
    if List.for_all is_var p1s then
      let contain_product = List.exists is_product p1s in
      var_rule contain_product ms eqs def
    else
      ctor_rule ms eqs def

and var_rule : bool -> matchees -> equations -> O.expression_content -> O.expression_content pm_result = fun contain_product ms eqs def ->
  let () = Format.printf "\nVAR RULE applies\n" in
  match ms with
  | mhd::mtl ->
    if contain_product then
      product_rule ms eqs def
    else
      let aux : pattern list * O.expression -> (pattern list * O.expression) pm_result = fun (pl, body) ->
        match pl with
        | P_var b::ptl -> (
          let%bind subst = substitute_var_in_body b.var mhd body in
          ok (ptl , subst)
        )
        | P_unit::ptl -> (
          ok (ptl,body)
        )
        | _ -> failwith "corner case"
      in
      let%bind eqs' = bind_map_list aux eqs in 
      match_ mtl eqs' def
  | [] -> failwith "corner case"

and ctor_rule : matchees -> equations -> O.expression_content -> O.expression_content pm_result = fun ms eqs def ->
  let () = Format.printf "\nCTOR RULE applies\n" in
  (* REMITODO Add a Const_list case which will be very similar to Constr but with a Match_list *)
  match ms with
  | mhd::mtl ->
    let ret lst =
      let cases = O.Match_variant lst in
      O.E_matching { matchee = O.e_variable mhd ; cases }
    in
    let%bind map = split_equations eqs in
    let lst = O.LMap.to_kv_list @@ map in
    (* REMITODO: labels should be checked against the type, if any constructor misses, append a None to the lst *)
    (* remove the folowing ofc*)
      (* let lst = List.sort_uniq (fun (O.Label la,_) (O.Label lb,_) -> String.compare la lb) lst in *)
      let lst = List.map (fun e -> Some e) @@ lst in
      let () = Format.printf "\n the ctor lmap has length: %d\n" @@ List.length lst in
      let lst = if List.length lst != 2 then  lst @ [None] else lst in
    (* remove the folowing ofc*)
    let aux : (O.label * equations) option -> O.match_variant pm_result =
      fun opt ->
        match opt with
        | Some (constructor , eq) ->
          (* let proj = match proj_opt with | Some v -> v | None -> Location.wrap @@ Var.fresh ~name:"_" () in
          let new_ms = match proj_opt with Some _ -> proj::mtl | None -> mtl in *)
          let proj = Location.wrap @@ Var.fresh ~name:"ctor_proj" () in (* REMITODO : if CTOR arity = 0, maybe the name can be changed to _ ? *)
          let new_ms = proj::mtl in (* REMITODO : if CTOR arity = 0 *)
          let () =
            Format.printf "CTOR: %a \n PROJ: %a \n new_EQ: %a\n new_MS %a\n\n"
              O.PP.label constructor O.PP.expression_variable proj pp_eqs eq pp_matchees new_ms
          in
          let%bind nested = match_ new_ms eq def in
          let body = O.make_e nested in
          ok @@ ({ constructor ; proj ; body } : O.match_variant)
        | None ->
          let () = Format.printf "\nMissing constructor in partition\n" in
          let proj = Location.wrap @@ Var.fresh ~name:"_" () in (* avec optimization, that *)
          let body = O.make_e def in
          ok @@ ({ constructor = Label "TODOExtractLabelFromType" ; proj ; body } : O.match_variant)
    in
    let%bind cases = bind_map_list aux lst in
    ok @@ ret cases
  | [] -> failwith "corner case"

and product_rule : matchees -> equations -> O.expression_content -> O.expression_content pm_result = fun ms eqs def ->
  let () = Format.printf "Product rule applies\n" in
  match ms with
  | mhd::_ -> (
    let product_shape =
      (* here we make the assumption that tuple/record of different size would have triggered an error earlier (typer) *)
      let eq_opt = List.find_opt (fun (pl,_) -> match pl with p::_ -> is_product p | _ -> false) eqs in
      match eq_opt with
      | Some (p::_,_) -> p
      | _ -> failwith "cornercase"
    in
    let filler =
      match product_shape with
      | P_tuple ps | P_record (_,ps) ->
        List.map (fun _ -> make_var_pattern (Location.wrap @@ Var.fresh ~name:"_filler" ())) ps
      | _ -> failwith "cornercase"
    in
    let aux : pattern list * O.expression -> (pattern list * O.expression) pm_result = fun (pl, body) ->
      match pl with
      | prod::ptl -> (
        match prod with
        | P_tuple ps | P_record (_,ps) ->
          let var_filler = make_var_pattern (Location.wrap @@ Var.fresh ~name:"_filler" ()) in
          ok (ps @ var_filler::ptl , body)
        | P_var _ | P_unit ->
          ok (filler @ pl , body)
        | _ -> failwith "corner case"
      )
      | [] -> failwith "corner case"
    in
    let%bind eqs' = bind_map_list aux eqs in
    let lb =
      match product_shape with
      | P_tuple ps ->
        let aux : int -> _ -> (O.label * O.type_expression O.binder) =
          fun i _ -> O.Label (string_of_int i), { var = Location.wrap @@ Var.fresh ~name:"tuple_proj" () ; ascr = None }
        in
        List.mapi aux ps
      | P_record (labels,_) ->
        let aux : O.label -> (O.label * O.type_expression O.binder) =
          fun l -> l , { var = Location.wrap @@ Var.fresh ~name:"record_proj" () ; ascr = None }
        in
        List.map aux labels
      | _ -> failwith "corner case (impossible)"
    in
    let fields = O.LMap.of_list lb in
    let new_matchees = List.map (fun (_,(x:O.type_expression O.binder)) -> x.var) lb in
    let%bind body = match_ (new_matchees @ ms) eqs' def in
    let cases = O.Match_record { fields; body = O.make_e body } in
    let matchee = O.e_variable mhd in
    ok @@ O.E_matching { matchee ; cases }
  )
  | [] -> failwith "corner case"

and compile_matching matchee eqs =
    let p1s = List.map (fun el -> List.hd @@ fst el) eqs in
    let f = (* REMITODO : mmmmh ? *)
      if List.exists is_product p1s then
        product_rule
      else
        match_
    in
    let () = Format.printf "STARTING WITH:\n matchees: %a\n eqs: %a\n-----\n" pp_matchees [matchee] pp_eqs eqs in
    let def = O.E_literal O.Literal_unit in (*REMITODO failwith "impossible", to be optimized later ?*)
    f [matchee] eqs def