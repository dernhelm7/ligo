type storage = [int, list <int>];

type parameter = list <int>;

type returnx = [list <operation>, storage];

let x : list <int> = List();
let y : list <int> = List(3, 4, 5);
let z : list <int> = List(2, ...y);

let main = ([action, s] : [parameter, storage]) : returnx => {
  if (action == []) {
    return [(List() as list<operation>), s]
  }
  else {
    let [hd, ...tl] = action;
    return [(List() as list<operation>), [s[0] + hd, tl]]
  }
};

let size_ = (s : list <int>) : nat => List.length (s);

let fold_op = (s : list <int>) : int => {
  let aggregate = (t: [int, int]) => t[0] + t[1];
  return List.fold (aggregate, s, 10);
};

let map_op = (s : list <int>) : list <int> =>
  List.map ((cur : int) => cur + 1, s);

let iter_op = (s : list <int>) : unit => {
  let do_nothing = (useless : int) => unit;
  List.iter (do_nothing, s);
};
