type tokens = big_map <address, nat>;
type allowances = big_map <[address, address], nat>; /* (sender,account) -> value */

type storage = {
  tokens      : tokens,
  allowances  : allowances,
  total_amount : nat,
};

type transfer = {
  address_from : address,
  address_to   : address,
  value        : nat,
};

type approve = {
  spender : address,
  value   : nat,
};

type getAllowance = {
  owner    : address,
  spender  : address,
  callback : contract <nat>,
};

type getBalance = {
  owner    : address,
  callback : contract <nat>,
};

type getTotalSupply = {
  callback : contract <nat>,
};

type action =
| ["Transfer", transfer]
| ["Approve", approve]
| ["GetAllowance", getAllowance]
| ["GetBalance", getBalance]
| ["GetTotalSupply", getTotalSupply];

let transfer = ([p,s] : [transfer, storage]) : [list <operation>, storage] => {
  let new_allowances; 
  if (Tezos.sender == p.address_from) { 
	  new_allowances = s.allowances; 
  }
  else {
	  let opt = Big_map.find_opt ([Tezos.sender,p.address_from], s.allowances);
	  let authorized_value: nat = match(opt, {
	    Some: (value: nat) => value,
	    None: () => (0 as nat)
	  });
	  if (authorized_value < p.value) { 
	    (failwith ("Not Enough Allowance") as allowances); 
	  }
	  else { 
	    new_allowances = Big_map.update ((Tezos.sender,p.address_from), (Some (abs(authorized_value - p.value))), s.allowances); 
	  };
  };
  let opt = Big_map.find_opt (p.address_from, s.tokens);
  let sender_balance: nat = match (opt, {
	  Some: (value: nat) => value,
  	None: () => (0 as nat)
  });
  if (sender_balance < p.value) { 
	  (failwith ("Not Enough Balance") as [list <operation>, storage]); 
  }
  else {
	  let new_tokens = Big_map.update (p.address_from, (Some (abs(sender_balance - p.value))), s.tokens);
	  let opt = Big_map.find_opt (p.address_to, s.tokens);
	  let receiver_balance:nat  = match(opt, {
	    Some: (value: nat) => value,
	    None: () => (0 as nat)
	  });
	  let new_tokens2 = Big_map.update (p.address_to, (Some (receiver_balance + p.value)), new_tokens);
	  return [([] as list <operation>), { ...s,tokens:new_tokens2, allowances:new_allowances}];
  };
};

let approve = ([p,s] : [approve, storage]) : [list <operation>, storage] => {
  let opt = Big_map.find_opt ((p.spender, Tezos.sender), s.allowances);
  let previous_value:nat = match(opt, {
	  Some: (value: nat) => value,
	  None: () => (0 as nat)
  });
  if (previous_value > (0 as nat) && p.value > (0 as nat)) { 
    (failwith ("Unsafe Allowance Change") as [list <operation>, storage]); 
  }
  else {
    let new_allowances = Big_map.update ([p.spender, Tezos.sender], (Some (p.value)), s.allowances);
    return [([] as list <operation>), { ...s, allowances : new_allowances}];
  };
};

let getAllowance = ([p,s] : [getAllowance, storage]) : [list <operation>, storage] => {
  let opt = Big_map.find_opt ([p.owner, p.spender], s.allowances);
  let value = match(opt, {
	Some: (value: nat) => value,
	None: () => (0 as nat)
  });
  let op = Tezos.transaction (value, (0 as mutez), p.callback);
  return [[op], s];
};

let getBalance = ([p,s] : [getBalance, storage]) : [list <operation>, storage] => {
  let opt = Big_map.find_opt (p.owner, s.tokens);
  let value = match (opt, {
	  Some: (value: nat) => value,
	  None: () => (0 as nat)
  });
  let op = Tezos.transaction (value, (0 as mutez), p.callback);
	return [[op],s]
};

let getTotalSupply = ([p,s] : [getTotalSupply, storage]) : [list <operation>, storage] => {
  let total = s.total_amount;
  let op    = Tezos.transaction (total, (0 as mutez), p.callback);
  return [[op],s]
};


let main = ([a,s]: [action, storage]) =>
  match(a, {
	  Transfer: (p: transfer) => transfer([p, s]),
	  Approve: (p: approve) => approve ([p, s]),
	  GetAllowance: (p: getAllowance) => getAllowance ([p, s]),
	  GetBalance: (p: getBalance) => getBalance ([p, s]),
	  GetTotalSupply: (p: getTotalSupply) => getTotalSupply ([p, s])
  });