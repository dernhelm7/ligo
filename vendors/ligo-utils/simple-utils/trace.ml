type nonrec ('value, 'error) result = 'value

(** {1 Constructors} *)

let ok x = x

(* exception Trace of 'error *)
exception Troce

let fail (type a) (x : a) : ('value, a) result =
  let module M = struct exception F of a end in
  raise (M.F x)
[@@raises M.F]

let update_annotation (_ : 'error) = failwith "not implemented"

let to_stdlib_result : ('value, 'error) result -> ('value, 'error) Stdlib.result = fun x ->
  match x with
  | x -> Result.Ok x

(* Monadic operators *)

let bind f = function
  | x -> f x

let map f = function
  x -> (f x)

(* The lexical convention usually adopted for the bind function is
   [>>=], but ours comes from the Tezos code base, where the [result]
   bind is [>>?], and [Lwt]'s (threading library) is [>>=], and the
   combination of both is [>>=?]. *)

let (>>?)  x f = bind f x
let (>>|?) x f = map f x

(* Used by PPX_let, an OCaml preprocessor.

   What it does is that, when you only care about the case where a
   result isn't an error, instead of writing:

   [
   (* Stuff that might return an error *) >>? fun ok_value ->
   (* Stuff being done on the result *)
   ]

   You can write:

   [
   let%bind ok_value = (* Stuff that might return an error *)
   in (* Stuff being done on the result *)
   ]

   This is much more typical of OCaml. This makes the code more
   readable, easy to write and refactor. It is used pervasively in
   LIGO. *)

module Let_syntax = struct
  let bind m ~f = m >>? f
  module Open_on_rhs_bind = struct end
end

(* To be used when you only want to signal an error. It can be useful
   when followed by [trace_strong]. *)

let trace _tracer v = match v with
  | v -> v
  (* | Error err -> Error (tracer err) *)

(* Erase the current error stack, and replace it by the given
   error. It's useful when using [Assert] and you want to discard its
   autogenerated message. *)

let trace_strong _err = function
  v -> v
(* | Error _ -> Error err *)

let try_catch _handler = function
    _ as o -> o
  (* | Error e -> handler e *)

(* Check if there is no error. Useful for tests. *)
let to_bool = function
  | _ -> true
  (* | Error _ -> false *)

let to_option = function
  | o -> Some o
  (* | Error _ -> None *)

(* Convert a result to a json, if res in an error, the produces JSON
   will be empty, otherwise the provided to_json function will be
   used *)

let to_json to_json = function
  | v ->  to_json v
  (* | Error _ -> `Null *)

(* Convert an option to a result, with a given error if the parameter
   is None. *)

let trace_option error = function
  None -> fail error
| Some s -> ok s

let trace_assert_fail_option error = function
   None -> ok ()
 | Some _s -> fail error


(* Utilities to interact with other data-structure.  [bind_t] takes
   an ['a result t] and makes a ['a t result] out of it. It "lifts" the
   error out of the type.  The most common context is when mapping a
   given type. For instance, if you use a function that can fail in
   [List.map], you need to manage a whole list of results. Instead,
   you do [let%bind lst' = bind_list @@ List.map f lst], which will
   yield an ['a list].  [bind_map_t] is roughly syntactic sugar for
   [bind_t @@ T.map]. So that you can rewrite the previous example as
   [let%bind lst' = bind_map_list f lst].  Same thing with folds.
 *)

let bind_compose f g x =
  let%bind y = g x in
  f y

let bind_map_option f = function
    None -> ok None
| Some s -> f s >>? fun x -> ok (Some x)

let rec bind_list = function
      [] -> ok []
| hd::tl -> hd >>? fun hd -> bind_list tl >>? fun tl -> ok @@ hd :: tl
let bind_ne_list (hd, tl) =
  hd >>? fun hd -> bind_list tl >>? fun tl -> ok @@ (hd, tl)
let bind_smap (s:_ X_map.String.t) =
  let open X_map.String in
  let aux k v prev =
    prev >>? fun prev' ->
    v >>? fun v' ->
    ok @@ add k v' prev'
  in fold aux s (ok empty)

let bind_fold_smap f init (smap : _ X_map.String.t) =
  let aux k v prev =
    prev >>? fun prev' -> f prev' k v
  in X_map.String.fold aux smap init

let bind_map_smap f smap = bind_smap (X_map.String.map f smap)

let bind_concat l1 l2 =
  let%bind l1' = l1 in
  let%bind l2' = l2 in
  ok @@ (l1' @ l2')

let bind_map_list f lst = bind_list (List.map f lst)
let bind_map2_list f lst1 lst2 = bind_list (List.map2 f lst1 lst2)
let bind_mapi_list f lst = bind_list (List.mapi f lst)

let rec bind_map_list_seq f lst = match lst with
  | [] -> ok []
  | hd :: tl ->
      let%bind hd' = f hd in
      let%bind tl' = bind_map_list_seq f tl in
      ok (hd' :: tl')

let bind_map_ne_list : _ -> 'a X_list.Ne.t -> ('b X_list.Ne.t,_) result =
  fun f lst -> bind_ne_list (X_list.Ne.map f lst)

let bind_iter_list : (_ -> (unit,_) result) -> _ list -> (unit,_) result =
  fun f lst -> bind_map_list f lst >>? fun _ -> ok ()

let bind_location (x:_ Location.wrap) =
  x.wrap_content >>? fun wrap_content ->
  ok { x with wrap_content }

let bind_map_location  f x     = bind_location (Location.map f x)
let bind_fold_location f acc x = f acc x.Location.wrap_content
let bind_fold_map_location f acc x =
  f acc x.Location.wrap_content >>? fun (acc, wrap_content) ->
  ok (acc, { x with wrap_content })

let bind_fold_list f init lst =
  let aux x y = x >>? fun x -> f x y
  in List.fold_left aux (ok init) lst

let bind_fold_ne_list f init lst =
  let aux x y = x >>? fun x -> f x y
  in X_list.Ne.fold_left aux (ok init) lst

module TMap(X : Map.OrderedType) = struct
  module MX = Map.Make(X)
  let bind_fold_Map f init map =
    let aux k v x  =
      x >>? fun x ->
      f ~x ~k ~v
    in MX.fold aux map (ok init)

  let bind_map_Map f map =
    let aux k v map'  =
      map' >>? fun map' ->
      f ~k ~v >>? fun v' ->
      ok @@ MX.update k (function
          | None -> Some v'
          | Some _ ->
             failwith "Key collision: Should not happen in bind_map_Map")
        map'
    in MX.fold aux map (ok MX.empty)
end

let bind_fold_pair f init (a,b) =
  let aux x y = x >>? fun x -> f x y
  in List.fold_left aux (ok init) [a;b]

let bind_fold_triple f init (a,b,c) =
  let aux x y = x >>? fun x -> f x y
  in List.fold_left aux (ok init) [a;b;c]

let bind_fold_map_list f acc lst =
  let rec aux (acc, prev) f = function
    | [] -> ok (acc, prev)
    | hd :: tl ->
        f acc hd >>? fun (acc' , hd') ->
        aux (acc', hd'::prev) f tl in
  aux (acc , []) f lst >>? fun (acc' , lst') ->
  ok @@ (acc' , List.rev lst')

let bind_fold_map2_list f acc lst1 lst2 =
  let rec aux (acc, prev) f = function
    | [],[] -> ok (acc,prev)
    | hd1 :: tl1, hd2 :: tl2 ->
        f acc hd1 hd2 >>? fun (acc', hd) ->
          aux (acc', hd::prev) f (tl1,tl2) 
    | _ -> ok (acc,prev) in
    aux (acc, []) f (lst1,lst2) >>? fun (acc', lst') ->
    ok @@ (acc', List.rev lst')

let bind_fold_map_right_list = fun f acc lst ->
  let rec aux (acc , prev) f = function
    | [] -> ok (acc , prev)
    | hd :: tl ->
        f acc hd >>? fun (acc' , hd') ->
        aux (acc' , hd' :: prev) f tl
  in
  aux (acc , []) f (List.rev lst) >>? fun (_acc' , lst') ->
  ok lst'

let bind_fold_right_list f init lst =
  let aux x y = x >>? fun x -> f x y
  in X_list.fold_right' aux (ok init) lst

let bind_find_map_list error f lst =
  let aux lst =
    match lst with
    | [] -> fail error
    | hd :: _tl ->
        match f hd with
        (* | Error _ -> aux tl *)
        | o -> o
  in aux lst

let bind_list_iter f lst =
  let aux () y = f y in
  bind_fold_list aux () lst

let bind_or (a, _b) =
  match a with
  | _ as o -> o
  (* | _ -> b *)

let bind_map_or (fa, fb) c = bind_or (fa c, fb c)

let bind_and (a, b) =
  a >>? fun a ->
  b >>? fun b ->
  ok (a, b)

let bind_and3 (a, b, c) =
  a >>? fun a ->
  b >>? fun b ->
  c >>? fun c ->
  ok (a, b, c)

let bind_pair = bind_and

let bind_map_pair f (a, b) =
  bind_pair (f a, f b)

let bind_fold_map_pair f acc (a, b) =
  f acc a >>? fun (acc', a') ->
  f acc' b >>? fun (acc'', b') ->
  ok (acc'', (a', b'))

let bind_map_triple f (a, b, c) = bind_and3 (f a, f b, f c)

let bind_list_cons v lst = lst >>? fun lst -> ok (v::lst)

let rec bind_chain : ('a -> ('a,_) result) list -> 'a -> ('a,_) result =
  fun fs x ->
  match fs with
  | [] -> ok x
  | hd :: tl ->
    bind (bind_chain tl) (hd x)

let rec bind_chain_acc : ('a -> 'b -> ('a,_) result) list -> 'a -> 'b -> ('a,_) result =
  fun fs acc x ->
  match fs with
  | [] -> ok acc
  | hd :: tl ->
    hd acc x >>? fun acc ->
    bind_chain_acc tl acc x

let rec bind_chain_ignore_acc :
          ('a -> ('b * 'a, _) result) list -> 'a -> ('a,_) result =
  fun fs x ->
  match fs with
  | [] -> ok x
  | hd :: tl ->
    hd x >>? fun (_,aa) ->
    bind_chain_ignore_acc tl aa

(* Wraps a call that might trigger an exception in a result. *)

let generic_try err f = try ok @@ f () with _ -> fail err

(* Same, but with a handler that generates an error based on the
   exception, rather than a fixed error. *)

let specific_try handler f =
  try ok @@ f () with exn -> fail (handler exn)

(* Assertion module.
   TODO: Would make sense to move it outside Trace. *)

module Assert = struct
  let assert_fail err = function
    _ -> fail err
  (* |    _ -> ok () *)

  let assert_true err = function
    | true -> ok ()
    | false -> fail err

  let assert_list_size err lst n =
    assert_true err List.(length lst = n)

  let assert_list_empty err lst =
    assert_true err List.(length lst = 0)

  let assert_list_same_size err lsta lstb =
    assert_true err List.(length lsta = length lstb)
end
